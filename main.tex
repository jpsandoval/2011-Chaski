%%%%%%%%%%%%%
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
%\documentclass[runningheads]{llncs}
%\documentclass[10pt,letterpaper,twocolumn]{article}
\documentclass{sig-alternate}


% packages
\usepackage{xspace}
\usepackage{ifthen}
\usepackage{amsbsy}
\usepackage{amssymb}
\usepackage{balance}
\usepackage{booktabs}
\usepackage{graphicx}
\usepackage{multirow}
\usepackage{needspace}
\usepackage{microtype}
\usepackage{bold-extra}
\usepackage{subfigure}
\usepackage{wrapfig}


% constants
\newcommand{\Title}{Execution Blueprint: An Effective Visual Support to Monitor Software Execution}
\newcommand{\TitleShort}{\Title}
\newcommand{\Authors}{Juan Pablo Sandoval Alcocer, Alexandre Bergel}
\newcommand{\AuthorsShort}{J.P. Sandoval Alcocer, A. Bergel}

% references
\usepackage[colorlinks]{hyperref}
\usepackage[all]{hypcap}
\setcounter{tocdepth}{2}
\hypersetup{
	colorlinks=true,
	urlcolor=black,
	linkcolor=black,
	citecolor=black,
	plainpages=false,
	bookmarksopen=true,
	pdfauthor={\Authors},
	pdftitle={\Title}}

\def\chapterautorefname{Chapter}
\def\appendixautorefname{Appendix}
\def\sectionautorefname{Section}
\def\subsectionautorefname{Section}
\def\figureautorefname{Figure}
\def\tableautorefname{Table}
\def\listingautorefname{Listing}

% source code
\usepackage{xcolor}
\usepackage{textcomp}
\usepackage{listings}
\definecolor{source}{gray}{0.9}
\lstset{
	language={},
	% characters
	tabsize=3,
	upquote=true,
	escapechar={!},
	keepspaces=true,
	breaklines=true,
	alsoletter={\#:},
	breakautoindent=true,
	columns=fullflexible,
	showstringspaces=false,
	basicstyle=\footnotesize\sffamily,
	% background
	frame=single,
    framerule=0pt,
	backgroundcolor=\color{source},
	% numbering
	numbersep=5pt,
	numberstyle=\tiny,
	numberfirstline=true,
	% captioning
	captionpos=b,
	% formatting (html)
	moredelim=[is][\textbf]{<b>}{</b>},
	moredelim=[is][\textit]{<i>}{</i>},
	moredelim=[is][\color{red}\uwave]{<u>}{</u>},
	moredelim=[is][\color{red}\sout]{<del>}{</del>},
	moredelim=[is][\color{blue}\underline]{<ins>}{</ins>}}
\newcommand{\ct}{\lstinline[backgroundcolor=\color{white},basicstyle=\footnotesize\ttfamily]}
\newcommand{\lct}[1]{{\small\tt #1}}

% tikz
% \usepackage{tikz}
% \usetikzlibrary{matrix}
% \usetikzlibrary{arrows}
% \usetikzlibrary{external}
% \usetikzlibrary{positioning}
% \usetikzlibrary{shapes.multipart}
% 
% \tikzset{
% 	every picture/.style={semithick},
% 	every text node part/.style={align=center}}

% proof-reading
\usepackage{xcolor}
\usepackage[normalem]{ulem}
\newcommand{\ra}{$\rightarrow$}
\newcommand{\ugh}[1]{\textcolor{red}{\uwave{#1}}} % please rephrase
\newcommand{\ins}[1]{\textcolor{blue}{\uline{#1}}} % please insert
\newcommand{\del}[1]{\textcolor{red}{\sout{#1}}} % please delete
\newcommand{\chg}[2]{\textcolor{red}{\sout{#1}}{\ra}\textcolor{blue}{\uline{#2}}} % please change
\newcommand{\chk}[1]{\textcolor{ForestGreen}{#1}} % changed, please check

% comments \nb{label}{color}{text}
\newboolean{showcomments}
\setboolean{showcomments}{true}
\ifthenelse{\boolean{showcomments}}
	{\newcommand{\nb}[3]{
		{\colorbox{#2}{\bfseries\sffamily\scriptsize\textcolor{white}{#1}}}
		{\textcolor{#2}{\sf\small$\blacktriangleright$\textit{#3}$\blacktriangleleft$}}}
	 \newcommand{\version}{\emph{\scriptsize$-$Id$-$}}}
	{\newcommand{\nb}[2]{}
	 \newcommand{\version}{}}
\newcommand{\rev}[2]{\nb{Reviewer #1}{red}{#2}}
\newcommand{\ab}[1]{\nb{Alexandre}{blue}{#1}}
\newcommand{\vp}[1]{\nb{Vanessa}{orange}{#1}}
\newcommand{\jp}[1]{\nb{Juan Pablo}{green}{#1}}

% graphics: \fig{position}{percentage-width}{filename}{caption}
\DeclareGraphicsExtensions{.png,.jpg,.pdf,.eps,.gif}
\graphicspath{{figures/}}
\newcommand{\fig}[4]{
	\begin{figure}[#1]
		\centering
		\includegraphics[width=#2\textwidth]{#3}
		\caption{\label{fig:#3}#4}
	\end{figure}}

\newcommand{\largefig}[4]{
	\begin{figure*}[#1]
		\centering
		\includegraphics[width=#2\textwidth]{#3}
		\caption{\label{fig:#3}#4}
	\end{figure*}}
	
\newcommand{\wrapfig}[5]{	
\begin{wrapfigure}{#1}{#2\textwidth}
  \begin{center}
    \includegraphics[width=#3\textwidth]{#4}
  \end{center}
  \caption{\label{fig:#4}#5}
\end{wrapfigure}}
	
% abbreviations
\newcommand{\ie}{\emph{i.e.,}\xspace}
\newcommand{\eg}{\emph{e.g.,}\xspace}
\newcommand{\etc}{\emph{etc.}\xspace}
\newcommand{\etal}{\emph{et al.}\xspace}

% lists
\newenvironment{bullets}[0]
	{\begin{itemize}}
	{\end{itemize}}

\newcommand{\seclabel}[1]{\label{sec:#1}}
\newcommand{\figlabel}[1]{\label{fig:#1}}
\newcommand{\figref}[1]{Figure~\ref{fig:#1}}
\newcommand{\secref}[1]{Section~\ref{sec:#1}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% adding smalltalk listing %%%%%%%%%%%%%%%%%%%5
\lstdefinelanguage{Smalltalk}{
  morekeywords={true,false,self,super,nil},
  sensitive=true,
  morecomment=[s]{"}{"},
  morestring=[d]',
  style=SmalltalkStyle
}
\lstdefinestyle{SmalltalkStyle}{
  literate={:=}{{$\gets$}}1{^}{{$\uparrow$}}1
} 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% adding smalltalk listing %%%%%%%%%%%%%%%%%%%5

%Specialized macros
\newcommand{\hapao}{Hapao\xspace}
\newcommand{\Hapao}{Hapao\xspace}
\pagenumbering{arabic}

\begin{document}

\title{\Title}
%\titlerunning{\TitleShort}

\author{\Authors\\[3mm]
Department of Computer Science (DCC)\\ University of Chile, Santiago, Chile\\[1 ex]
} 
%\authorrunning{\AuthorsShort}

\maketitle

\emph{This paper makes use of colored figures. Though colors are not mandatory for full understanding, we recommend  the use of a colored printout.}

%We currently know little about the execution of software in general. Most of the tools we use to construct software focus on static abstractions (class and method definitions) instead of message sending. Little options are offered to developers to fully understand how objects interact. 
%As a consequence, developers have to resort to ad-hoc solutions to identify redundant computation, excessive memory consumption and odd interactions. 


\begin{abstract}
%	What's the problem.
%	Why is the problem a problem?
%	What's the surprising idea?
%	What's the consequence?

%Understanding the behavior of software is an essential task of the software life cycle, especially when performance monitoring activities have to be maintained.
Traditional code profilers and debuggers for object-oriented programming languages essentially consider a software as a bunch of classes and methods, defined in textual files. These abstractions poorly match with what a computation is made of: objects sending and receiving messages. A sever consequence is that developers often turn to ad-hoc solutions to identify redundant computation, excessive memory consumption and odd interactions.  %understand better the execution.

We propose \emph{execution blueprints} to visually identify execution patterns. Our blueprints offer intuitive execution representations, useful to identify abnormal and odd object interactions. 
Adequate combinations of layouts and coloring reveals certain execution anomalies and performances issues.

Thanks to our framework Chaski, we were able to find a number of serious defect in applications written in Pharo.

%Our goal is to show a visualization that represents the interaction of objects involved in the execution which can help developers gain a better understanding of the software execution. The large number of objects involved in execution represents a major challenge.
%
%Chaski is a tool to address this problem of understanding by visualizing the execution of an object oriented program. Execution blueprint shows the interaction between objects through messages exchanged between them, in the order they occur. \ab{Say more about the visualization}. This visualization helps to: understand the current behavior of the software, find candidates for refactoring and optimization, show dependencies and relations, among others.
\end{abstract}

%: % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %

\section{Introduction}\seclabel{introduction}

%Dynamic analysis 

Data-mining program execution traces is known to be difficult. Exploring a real-world list of sequence execution events cannot be effective without addressing scalability issues~\cite{Kuhn06c} and supporting expressive queries~\cite{Zaid05a}. 

Visualizing execution trace has recently been identified as a promising approach to manage scalability and pattern recognition~\cite{Maoz11a,Zaid05a,Reis07a}. %Numerous approaches have been proposed in that respect. 

Maletic \etal~\cite{Male02a} state ``no single software visualization tool can address all software engineering tasks simultaneously.'' However, when we retrospectively look at the existing trace visualization engines, it is startling to see that the great majority are rigid in the visual representation they support. Visualizations are usually targeted at identifying one family of patterns.% and the engine behind is hardly extendable. 

Consider circular bundle view proposed by Cornelissen \etal~\cite{Corn08a}. Structural program elements are on the circumference of a circle and runtime invocations are bundled based on B-spline curves~\cite{Holt06b}. Whereas the visualization is adjustable (\eg high-level structural entities may be collapsed) the range of discoverable patterns remains constant. The situation is similar with other visualization engines, including TraceVis~\cite{Deel07a} and Tracer~\cite{Maoz11a}.

 

%~\cite{Male02a}
%Tasks -- why is the visualization needed?
%Audience -- who will use the visualization?
%Target -- what is the data source to represent?
%Representation -- how to represent it?
%Medium -- where to represent the visualization?

We address this problem by proposing a framework for \emph{execution blueprints}, a blueprint being a tailored visual trace representation. An execution blueprint aims at identifying problematic execution patterns. From a given execution trace of an object-oriented application, an execution blueprint visualizes the exchanged messages and the object involved in the profiled computation.

A blueprint is parametrized with a layout and a color map. The layout assigns to each message a physical position on the screen and the color map assigns a color against some property of the message.

We implemented our blueprint in Chaski, a framework for execution trace visualization. Chaski allows one to easily define a new blueprint with a customized layout and color map.

This paper is structured as follows. 
\secref{executionBlueprints} presents two execution blueprints
\secref{caseStudy} employs the blueprints to identify execution anomalies in an application large of 200 classes.


%The use of highly reflective dynamic languages can make seemingly simple questions(how 2 or more packages interact? What kinds are dependent to a certain class? When exactly this method is invoked?)difficult to answer if we just analyze the source code, documentation or any other appliance design.
%
%To answer these questions among others and to improve the process of understanding, it is necessary to make a dynamic analysis, or analysis of data retrieved from the execution of a program.
%
%In this context, we propose a visualization of the execution of an object oriented program, showing the interaction between objects through messages exchanged between them, in the order they occur. While understanding the overall behavior of the system is ideal, this visualization was intended to be used by objectives, in other words, to analyze portions of the application that really interest us to achieve an objective.
%
%The purpose of this visualization is to help: understand the current behavior of the software, find candidates for refactoring and optimization, show dependencies and relations, among others.
%

%: % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\section{Execution Blueprints} \seclabel{executionBlueprints}

%We define \emph{execution blueprints} as a visual representation of an execution trace. 
%
%In order for our approach to be effective, the execution trace has to contains the names of messages that are sent and an unique identification of the object receiver. 
%
%An execution trace is a structure in which the profiled information is stored\ab{Give a reference, I guess this is not your definition}. Execution blueprint is a post mortem analysis, implying that the software execution has terminated. 
%
%A computation in an object-oriented language is exercised with objects interacting by sending messages to themselves. 

We proposes two execution blueprints, a \emph{message-centric blueprint} that emphasizes on the messages sent between objects and an \emph{object-centric blueprint} to represents the interactions between objects.

A blueprint represents a message and an object as a small colored box. Edges between two boxes represents the sequence between messages. As discussed below, the differences between the two blueprints is essentially based on the color map and the layout.

We illustrate the blueprint on contrived but representative examples. The following sections will study their applications on a large case study.

%\subsection{Chaski objectives}
%
%
%The main purpose of Chaski is to help programmers find problems or anomalies on the application using execution traces. We found that each visualizations can help to detect a limited number of problems. In the following section we present the Chaski layouts and their purpose.
%
%Interesting problems that visualization can help to solve are: understand the current behavior of the software, find candidates for refactoring and optimization, show dependencies and relationship, among others.

%============1

\subsection{Message-centric execution blueprint}

\fig{}{0.4}{TreeLayout2}{Message-centric execution blueprint\ab{Remove "(22)", it is irrelevant for our purpose}}

\paragraph{Specification}

The message-centric blueprint renders messages as boxes and execution order as edges.

red = 

Colors help us to find identity behavior \ab{What is an identify behavior?}. To find identity behavior we only need to select a sequence of messages (sub-tree) and automatically all identity sequence of messages (sub-tree) are colored with red and yellow. The colors are set with the following criteria: the red boxes are messages that: i) they have the same selector ii) they are received by the same object; and the yellow boxes are messages that: i) they have the same selector ii) the receivers of these messages are instances of the same class.

\paragraph{Interpretation}

This blueprint helps us to find identity behavior, for example in \figref{TreeLayout} we can see all sent messages in an execution, the root message or event message is the responsible of invoking all other messages(A).  Note that there are 5 sub-tree structure like, but only 3 of them are painted with colors red and yellow(B), because these sub-trees have identity behavior.

Finding identity behavior helps us to detect possible points where we can apply a cache. For example, red messages cause the same sequence of messages and they are received by the same object. The cache stores data so that future invocation of a same method for that data can be retrieved faster.

\paragraph{Interaction}

The trigger to search identity behavior is a click in the root message of a sub-tree. Also we can press a right click in any message to inspect the method associated with the message.

%============
\subsection{Object-centric execution blueprint}

\fig{}{0.5}{Demo}{Sequence Layout}

\paragraph{Specification}

This layout distinguishes three types of components: classifiers, messages and edges (\figref{Demo}). The classifiers are displayed as blue, red and yellow boxes that represent a package, class and object respectively(A). The gray boxes represent messages(B), and the edges link pairs of messages where a message is related to the message from which it was invoked.
Classifiers are displayed as a composition. Note that in the \figref{Demo} the packages are composed by its classes and each class is composed by the objects that were instantiated from it (E).
The messages are vertically aligned with the component receiving the message(D), and placed horizontally in the order in which these messages are received(timeline).

\paragraph{Interpretation}

This blueprint shows how many objects are in the execution, the messages that they received and the interaction between objects through messages exchanged between them, in the order they occur.

\paragraph{Interaction}

Also we can press a right click in any message to inspect the method associated with the message.

%============1

%: % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %

\section{The Chaski Framework}\seclabel{framework}

Chaski is a framework to visualize object oriented execution traces. 

Also we can define a new layout quickly, and set different colors to the messages based on a particular criteria, depending on what we want to use the visualization for.


In this section we show how to you define a new layout. For this we use Chaski to create a known visualization named "Execution Mural" [??]. The Execution Mural shows time on the horizontal axis and messages passed between classes in a program on the vertical. This take the approach of creating a general view showing all the classes and messages. Where the classes are on vertical axis, and each message is single line of 1 pixel wide from source to destination class.

Basically we need to create an specification of ChaskiLayout, and overwrite the "applyLayoutWith:" method.
\begin{lstlisting}[language=Smalltalk]
MuralLayout>>applyLayoutWith: profiledInformation
|classes messages|

"Select what information we want show, in this case classes and messages"
classes := profiledInformation allClasses.
messages := profiledInformation allReceivedMessages.	

"Set x, y, width, height and color properties"
self applyLayoutOnClasses: classes.
self applyLayoutOnMessages: messages.

"Mondrian script"
view shape rectangle fillColor: [ : model | model moNode color];
		width: [ : model | model moNode width];
		height:  [ : model | model moNode height] ; 
		disableCache;
		text:[: model |  model className ].
view nodes: classes.
view shape rectangle fillColor: [ : model | model moNode color];
		width: [ : model | model moNode width];
		height:  [ : model | model moNode height] ; 
		withoutBorder;
		disableCache.
view nodes: messages.
""
\end{lstlisting}
\begin{lstlisting}[language=Smalltalk]
MuralLayout>>applyLayoutOnClasses: classes
|xo yo|
xo := 5. yo := 5.
classes do: [ : class | 
	class moNode x: xo.   
	class moNode y: yo.
	class moNode width: defaultWidth. 
	class moNode height: defaultHeight. 
	yo := yo + defaultHeight.].
\end{lstlisting}
\begin{lstlisting}[language=Smalltalk]
MuralLayout>>applyLayoutOnMessages: messages
|xo a b c|
xo := defaultWidth +12.
messages do: [ :m | 
	m sender ifNotNil: [ "maybe the sender is in a package no profiled"
		a := m sender  cclass moNode y.
		b := m receiver cclass moNode y + m receiver cclass moNode height.
		(a > b) ifTrue: [ c:= b. b:=a. a:=c. ].
		m moNode height: (b - a).
		m moNode width: 1.
		m moNode y:  a.
		m moNode x: xo.
		m moNode color: Color gray.
		xo := xo+m moNode width.
	]. ].
\end{lstlisting}

After to defining the layout we need set it before open the visualization. 
\begin{lstlisting}[language=Smalltalk]
Chaski  profile:[
	|view|
	view := MOViewRenderer new.
	view nodes: MOGraphElement withAllSubclasses.
	view edgesFrom: #superclass.
] inPackagesMatching: 'Mondrian-*'.
Chaski layout: MuralLayout new.
Chaski open.
\end{lstlisting}
\fig{}{0.5}{ExecutionMural}{Execution Mural}
The code above creates the visualization depicted in \figref{ExecutionMural}



%: % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %

\section{Case of Study}\seclabel{caseStudy}

In this section we show how Chaski visualizations help to improve the performance of Mondrian.
For this we use this Mondrian script as an example:
\begin{lstlisting}[language=Smalltalk]
Chaski  profile:[
	|view|
	view := MOViewRenderer new.
	view nodes: MOShape withAllSubclasses.
	view edgesFrom: #superclass.
	view treeLayout.
	view open.
] inPackagesMatching: 'Mondrian-*'.
\end{lstlisting}

This script generates an easy visualization that corresponds a MOShape class hierarchy depicted on \figref{MondrianExample}, where each node is a class, edges designate inheritance. In this simple example 400 objects of Mondrian were created and they received 12687 messages.

\begin{center}
   \begin{tabular}{|l||ccr|} \hline
	Class & Instances & Messages \\
	MOMorphPainterVisitor & 1 & 51	\\
	MORectangleShape & 2 & 1602	\\
	MOStraightLineShape & 1 & 296	\\
	MOTreeLayout & 1 & 536	\\
	ConcreteShapeVisitor & 49 & 98 \\
	MONode & 300 & 5693\\
	MOElementShapeProperties & 10 & 85\\
	MOViewRenderer & 1 & 292\\
	MOEdge & 24 & 3442\\
	MORoot & 6 & 548\\
	MOBrowser & 1 & 11\\
	MOCanvas & 1 & 9\\
	MOAnnouncer & 3 & 24\\
	Total & 400 & 12687 \\
   \end{tabular}
\end{center}

We get surprised with these result: Why 300 objects of MONode were created if "MOShape withAllSubclasses" only are 25 elements?. We search in the extend code and we could not find the reason. This simple anomalies brought us to follow many questions: Are 400 objects really needed? Where are used these objects? Are 12687 messages needed? Can we reduce the number of messages?.

\subsection{Using Tree Layout}

\largefig{}{1.0}{MondrianTreeLayout}{Mondrian Tree Layout}

In this section we visualize the following instruction using Tree Layout (\figref{MondrianTreeLayout}):
\begin{lstlisting}[language=Smalltalk]
|view|
Chaski profile: [
	view := MOViewRenderer new.
	view nodes: ChaskiLayout withAllSubclasses.
	]  inPackagesMatching: 'Mondrian-*'.
Chaski layout treeMessageLayout.
Chaski open.
\end{lstlisting}


In this context we can analyze the red message:
\begin{lstlisting}[language=Smalltalk]
defaultNodeShapeClass
"Return the default node shape class"
| classes |

classes := (self allSubclasses select: #isDefaultNodeShape).
classes ifEmpty: [ self error: 'No default shape class' ].

^ classes anyOne
\end{lstlisting}

This code clearly does a search twice during the execution, and the search is independent of the context because this method doesn't receive parameters and also doesn't use an instance variable. Clearly this is a method we can improve using cache.
\begin{lstlisting}[language=Smalltalk]
defaultNodeShapeClass
"Return the default node shape class"

| classes |
DefaultNodeShapeClass ifNotNil: [ ^ DefaultNodeShapeClass ].
classes := (self allSubclasses select: #isDefaultNodeShape).
classes ifEmpty: [ self error: 'No default shape class' ].

^ DefaultNodeShapeClass := classes anyOne.

\end{lstlisting}

\subsection{Using Sequence Layout}

\largefig{}{1.0}{MondrianSequenceLayout}{Sequence Tree Layout}
In this section we visualize the following instructions using Sequence Layout (\figref{}):
\begin{lstlisting}[language=Smalltalk]
|view|
view := MOViewRenderer new.
view nodes: ChaskiLayout withAllSubclasses.
Chaski profile: [
	view edgesFrom:#superclass.
	]  inPackagesMatching: 'Mondrian-*'.
Chaski layout treeMessageLayout.
Chaski open.
\end{lstlisting}

In this section we will examine \figref{Before1}. The first execution anomaly that we can found is in the section (A), where there are some objects that receive only one message in the execution. The following code correspond to these messages.

\begin{lstlisting}[language=Smalltalk]
MOGraphElement>>allNodesDo: aBlock
	"Evaluate aBlock all its children."
	self copy nodesDo: [ :each |
		aBlock value: each.
		each allNodesDo: aBlock ]
\end{lstlisting} 

This is a wierd code, because "self copy" do a shadow copy of the receiver node, and call to nodesDo: selector.

\begin{lstlisting}[language=Smalltalk]
MONode>>nodesDo: aBlock
	"Iterates over all the subnodes of the receiver."	
	nodes ifNil: [ ^ self ].
	nodes do: aBlock
\end{lstlisting} 

And this do something with the original subnodes, this is possible to see in the visualization, but the copy nodes do nothing after that because nobody save it's reference. This is clearly an issue  and it is consuming memory needlessly.

For the first execution anomaly, we refactor the ``allNodesDo:'' method: 
\begin{lstlisting}[language=Smalltalk]
MOGraphElement>>allNodesDo: aBlock
	"Evaluate aBlock all its children."
	self nodesDo: [ :each |
		aBlock value: each.
		each allNodesDo: aBlock ]
\end{lstlisting} 

\begin{center}
   \begin{tabular}{|l||ccr|} \hline
	Class & Instances & Messages \\
	MOMorphPainterVisitor & 1 & 51	\\
	MORectangleShape & 2 & 1602	\\
	MOStraightLineShape & 1 & 296	\\
	MOTreeLayout & 1 & 536	\\
	ConcreteShapeVisitor & 49 & 98 \\
	MONode & 25 & 5693\\
	MOElementShapeProperties & 10 & 91\\
	MOViewRenderer & 1 & 292\\
	MOEdge & 24 & 3442\\
	MORoot & 1 & 548\\
	MOBrowser & 1 & 11\\
	MOCanvas & 1 & 9\\
	MOAnnouncer & 3 & 24\\
	Total & 120 & 12696 \\
   \end{tabular}
\end{center}

\section{Discussion}\seclabel{discussion}

The large-scale sequence of messages makes the screen resolution not enough to show a lot of information,causing the emergence of scrolls that make the graphics difficult to understand. 
%Group the messages only by class and packages reduce the height of a visualization. However the big number of messages remains a problem.



\section{Related work}\seclabel{relatedwork}

Research into trace visualization has resulted in various techniques and tools.

\paragraph{Execution pattern}~\cite{Pauw98a}

Execution trace visualization
~\cite{Maoz11a}
%: % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\section{Conclusion}\seclabel{conclusion}

%\paragraph{Acknowledgment}
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %

\bibliographystyle{plain}
\bibliography{scg}

\end{document}

