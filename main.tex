%%%%%%%%%%%%%
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
%\documentclass[runningheads]{llncs}
%\documentclass[10pt,letterpaper,twocolumn]{article}
\documentclass{sig-alternate}


% packages
\usepackage{xspace}
\usepackage{ifthen}
\usepackage{amsbsy}
\usepackage{amssymb}
\usepackage{balance}
\usepackage{booktabs}
\usepackage{graphicx}
\usepackage{multirow}
\usepackage{needspace}
\usepackage{microtype}
\usepackage{bold-extra}
\usepackage{subfigure}
\usepackage{wrapfig}


% constants
\newcommand{\Title}{Execution Blueprint: An Effective Visual Support to Monitor Software Execution}
\newcommand{\TitleShort}{\Title}
\newcommand{\Authors}{Juan Pablo Sandoval Alcocer, Alexandre Bergel}
\newcommand{\AuthorsShort}{J.P. Sandoval Alcocer, A. Bergel}

% references
\usepackage[colorlinks]{hyperref}
\usepackage[all]{hypcap}
\setcounter{tocdepth}{2}
\hypersetup{
	colorlinks=true,
	urlcolor=black,
	linkcolor=black,
	citecolor=black,
	plainpages=false,
	bookmarksopen=true,
	pdfauthor={\Authors},
	pdftitle={\Title}}

\def\chapterautorefname{Chapter}
\def\appendixautorefname{Appendix}
\def\sectionautorefname{Section}
\def\subsectionautorefname{Section}
\def\figureautorefname{Figure}
\def\tableautorefname{Table}
\def\listingautorefname{Listing}

% source code
\usepackage{xcolor}
\usepackage{textcomp}
\usepackage{listings}
\definecolor{source}{gray}{0.9}
\lstset{
	language={},
	% characters
	tabsize=3,
	upquote=true,
	escapechar={!},
	keepspaces=true,
	breaklines=true,
	alsoletter={\#:},
	breakautoindent=true,
	columns=fullflexible,
	showstringspaces=false,
	basicstyle=\footnotesize\sffamily,
	% background
	frame=single,
    framerule=0pt,
	backgroundcolor=\color{source},
	% numbering
	numbersep=5pt,
	numberstyle=\tiny,
	numberfirstline=true,
	% captioning
	captionpos=b,
	% formatting (html)
	moredelim=[is][\textbf]{<b>}{</b>},
	moredelim=[is][\textit]{<i>}{</i>},
	moredelim=[is][\color{red}\uwave]{<u>}{</u>},
	moredelim=[is][\color{red}\sout]{<del>}{</del>},
	moredelim=[is][\color{blue}\underline]{<ins>}{</ins>}}
\newcommand{\ct}{\lstinline[backgroundcolor=\color{white},basicstyle=\footnotesize\ttfamily]}
\newcommand{\lct}[1]{{\small\tt #1}}

% tikz
% \usepackage{tikz}
% \usetikzlibrary{matrix}
% \usetikzlibrary{arrows}
% \usetikzlibrary{external}
% \usetikzlibrary{positioning}
% \usetikzlibrary{shapes.multipart}
% 
% \tikzset{
% 	every picture/.style={semithick},
% 	every text node part/.style={align=center}}

% proof-reading
\usepackage{xcolor}
\usepackage[normalem]{ulem}
\newcommand{\ra}{$\rightarrow$}
\newcommand{\ugh}[1]{\textcolor{red}{\uwave{#1}}} % please rephrase
\newcommand{\ins}[1]{\textcolor{blue}{\uline{#1}}} % please insert
\newcommand{\del}[1]{\textcolor{red}{\sout{#1}}} % please delete
\newcommand{\chg}[2]{\textcolor{red}{\sout{#1}}{\ra}\textcolor{blue}{\uline{#2}}} % please change
\newcommand{\chk}[1]{\textcolor{ForestGreen}{#1}} % changed, please check

% comments \nb{label}{color}{text}
\newboolean{showcomments}
\setboolean{showcomments}{true}
\ifthenelse{\boolean{showcomments}}
	{\newcommand{\nb}[3]{
		{\colorbox{#2}{\bfseries\sffamily\scriptsize\textcolor{white}{#1}}}
		{\textcolor{#2}{\sf\small$\blacktriangleright$\textit{#3}$\blacktriangleleft$}}}
	 \newcommand{\version}{\emph{\scriptsize$-$Id$-$}}}
	{\newcommand{\nb}[2]{}
	 \newcommand{\version}{}}
\newcommand{\rev}[2]{\nb{Reviewer #1}{red}{#2}}
\newcommand{\ab}[1]{\nb{Alexandre}{blue}{#1}}
\newcommand{\vp}[1]{\nb{Vanessa}{orange}{#1}}
\newcommand{\jp}[1]{\nb{Juan Pablo}{green}{#1}}

% graphics: \fig{position}{percentage-width}{filename}{caption}
\DeclareGraphicsExtensions{.png,.jpg,.pdf,.eps,.gif}
\graphicspath{{figures/}}
\newcommand{\fig}[4]{
	\begin{figure}[#1]
		\centering
		\includegraphics[width=#2\textwidth]{#3}
		\caption{\label{fig:#3}#4}
	\end{figure}}

\newcommand{\largefig}[4]{
	\begin{figure*}[#1]
		\centering
		\includegraphics[width=#2\textwidth]{#3}
		\caption{\label{fig:#3}#4}
	\end{figure*}}
	
\newcommand{\wrapfig}[5]{	
\begin{wrapfigure}{#1}{#2\textwidth}
  \begin{center}
    \includegraphics[width=#3\textwidth]{#4}
  \end{center}
  \caption{\label{fig:#4}#5}
\end{wrapfigure}}
	
% abbreviations
\newcommand{\ie}{\emph{i.e.,}\xspace}
\newcommand{\eg}{\emph{e.g.,}\xspace}
\newcommand{\etc}{\emph{etc.}\xspace}
\newcommand{\etal}{\emph{et al.}\xspace}

% lists
\newenvironment{bullets}[0]
	{\begin{itemize}}
	{\end{itemize}}

\newcommand{\seclabel}[1]{\label{sec:#1}}
\newcommand{\figlabel}[1]{\label{fig:#1}}
\newcommand{\figref}[1]{Figure~\ref{fig:#1}}
\newcommand{\secref}[1]{Section~\ref{sec:#1}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% adding smalltalk listing %%%%%%%%%%%%%%%%%%%5
\lstdefinelanguage{Smalltalk}{
  morekeywords={true,false,self,super,nil},
  sensitive=true,
  morecomment=[s]{"}{"},
  morestring=[d]',
  style=SmalltalkStyle
}
\lstdefinestyle{SmalltalkStyle}{
  literate={:=}{{$\gets$}}1{^}{{$\uparrow$}}1
} 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% adding smalltalk listing %%%%%%%%%%%%%%%%%%%5

%Specialized macros
\newcommand{\hapao}{Hapao\xspace}
\newcommand{\Hapao}{Hapao\xspace}
\pagenumbering{arabic}

\begin{document}

\title{\Title}
%\titlerunning{\TitleShort}

\author{\Authors\\[3mm]
Department of Computer Science (DCC)\\ University of Chile, Santiago, Chile\\[1 ex]
} 
%\authorrunning{\AuthorsShort}

\maketitle

\emph{This paper makes use of colored figures. Though colors are not mandatory for full understanding, we recommend  the use of a colored printout.}

\begin{abstract}
%	What's the problem.
%	Why is the problem a problem?
%	What's the surprising idea?
%	What's the consequence?

Understanding the behavior of software is one essential task of the software life cycle, especially when maintenance activities have to be performed. One has to analyze the code, the documentation or any other device before making any changes therefore it becomes a difficult task and time consuming.

Our goal is to show a visualization that represents the interaction of objects involved in the execution which can help developers gain a better understanding of the software execution. The large number of objects involved in execution represents a major challenge.

Chaski is a tool to address this problem of understanding by visualizing the execution of an object oriented program. Execution blueprint shows the interaction between objects through messages exchanged between them, in the order they occur. \ab{Say more about the visualization}. This visualization helps to: understand the current behavior of the software, find candidates for refactoring and optimization, show dependencies and relations, among others.


\end{abstract}

%: % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %

\section{Introduction}\seclabel{introduction}

The use of highly reflective dynamic languages can make seemingly simple questions(how 2 or more packages interact? What kinds are dependent to a certain class? When exactly this method is invoked?)difficult to answer if we just analyze the source code, documentation or any other appliance design.

To answer these questions among others and to improve the process of understanding, it is necessary to make a dynamic analysis, or analysis of data retrieved from the execution of a program.

In this context, we propose a visualization of the execution of an object oriented program, showing the interaction between objects through messages exchanged between them, in the order they occur. While understanding the overall behavior of the system is ideal, this visualization was intended to be used by objectives, in other words, to analyze portions of the application that really interest us to achieve an objective.

The purpose of this visualization is to help: understand the current behavior of the software, find candidates for refactoring and optimization, show dependencies and relations, among others.


%: % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\section{A trace visualization framework}\seclabel{framework}

Chaski is a framework to visualize object oriented execution traces. An execution trace is a structure in which the profiled information is stored. The profiled information is retrieved after program execution (post mortem analysis). To obtain the profiled information, we need execute the application according to a well-defined execution scenario. Therefore we need to analyze those parts of the application that we are really interested.

Chaski separates the profiled information from the visualization, Chaski is able to display different visualizations from the same profiled information. Each visualization is defined by a layout, and has a different purpose.

Chaski provides three default layouts. Also we can define a new layout quickly, and set different colors to the messages based on a particular criteria, depending on what we want to use the visualization for.

\subsection{Chaski objectives}


The main purpose of Chaski is to help programmers find problems or anomalies on the application using execution traces. We found that each visualizations can help to detect a limited number of problems. In the following section we present the Chaski layouts and their purpose.

Interesting problems that visualization can help to solve are: understand the current behavior of the software, find candidates for refactoring and optimization, show dependencies and relationship, among others.

%: % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %

\subsection{Chaski layouts}

{\bf Tree Layout},

\fig{}{0.25}{TreeLayout}{Tree Layout}

This layout displays all  sent messages(boxes). And the edges link pairs of messages, where a message is related to the message from which it was invoked.

Using interactions (click) in the nodes(boxes) help us to find repetitive behavior, as we can see in the \figref{TreeWithColor}. Where the red boxes are messages that meet the following criteria: i) they have the same selector ii) they are received by the same object.The yellow boxes meet the following criteria: i) they have the same selector ii) the receivers of these messages are instances of the same class.
Colors help us to detect possible points where we can apply a cache, for example, red messages cause the same sequence of messages and they are received by the same object. The cache stores data so that future invocation of a same method for that data can be retrieved faster.

{\bf Sequence Layout},

\fig{}{0.5}{Demo}{Sequence Layout}

This layout distinguishes three types of components: classifiers, messages and edges (\figref{Demo}). The classifiers are displayed as blue, red and yellow boxes that represent a package, class and object respectively(A). The gray boxes represent messages(B). And the edges link pairs of messages, where a message is related to the message from which it was invoked.

The classifiers are displayed as a composition. Note that in the \figref{Demo} the packages are composed for its classes  and each class is composed from the objects that were instantiated from it (E).

The messages are vertically aligned with the component receiving the message(D), and placed horizontally in the order in which these messages are received (timeline).

\subsection{How do you define a new layout?}

In this section we show how to you define a new layout. For this we use Chaski to create a known visualization named "Execution Mural" [??]. The Execution Mural shows time on the horizontal axis and messages passed between classes in a program on the vertical. This take the approach of creating a general view showing all the classes and messages. Where the classes are on vertical axis, and each message is single line of 1 pixel wide from source to destination class.

Basically we need to create an specification of ChaskiLayout, and overwrite the "applyLayoutWith:" method.
\begin{lstlisting}[language=Smalltalk]
MuralLayout>>applyLayoutWith: profiledInformation
|classes messages|

"Select what information we want show, in this case classes and messages"
classes := profiledInformation allClasses.
messages := profiledInformation allReceivedMessages.	

"Set x, y, width, height and color properties"
self applyLayoutOnClasses: classes.
self applyLayoutOnMessages: messages.

"Mondrian script"
view shape rectangle fillColor: [ : model | model moNode color];
		width: [ : model | model moNode width];
		height:  [ : model | model moNode height] ; 
		disableCache;
		text:[: model |  model className ].
view nodes: classes.
view shape rectangle fillColor: [ : model | model moNode color];
		width: [ : model | model moNode width];
		height:  [ : model | model moNode height] ; 
		withoutBorder;
		disableCache.
view nodes: messages.
""
\end{lstlisting}
\begin{lstlisting}[language=Smalltalk]
MuralLayout>>applyLayoutOnClasses: classes
|xo yo|
xo := 5. yo := 5.
classes do: [ : class | 
	class moNode x: xo.   
	class moNode y: yo.
	class moNode width: defaultWidth. 
	class moNode height: defaultHeight. 
	yo := yo + defaultHeight.].
\end{lstlisting}
\begin{lstlisting}[language=Smalltalk]
MuralLayout>>applyLayoutOnMessages: messages
|xo a b c|
xo := defaultWidth +12.
messages do: [ :m | 
	m sender ifNotNil: [ "maybe the sender is in a package no profiled"
		a := m sender  cclass moNode y.
		b := m receiver cclass moNode y + m receiver cclass moNode height.
		(a > b) ifTrue: [ c:= b. b:=a. a:=c. ].
		m moNode height: (b - a).
		m moNode width: 1.
		m moNode y:  a.
		m moNode x: xo.
		m moNode color: Color gray.
		xo := xo+m moNode width.
	]. ].
\end{lstlisting}

After to defining the layout we need set it before open the visualization. 
\begin{lstlisting}[language=Smalltalk]
Chaski  profile:[
	|view|
	view := MOViewRenderer new.
	view nodes: MOGraphElement withAllSubclasses.
	view edgesFrom: #superclass.
] inPackagesMatching: 'Mondrian-*'.
Chaski layout: MuralLayout new.
Chaski open.
\end{lstlisting}
\fig{}{0.5}{ExecutionMural}{Execution Mural}
The code above creates the visualization depicted in \figref{ExecutionMural}

\section{Case of Study}\seclabel{case study}

In this section we show how Chaski visualizations help to improve the performance of Mondrian.
For this we use this Mondrian script as an example:
\begin{lstlisting}[language=Smalltalk]
Chaski  profile:[
	|view|
	view := MOViewRenderer new.
	view nodes: MOShape withAllSubclasses.
	view edgesFrom: #superclass.
	view treeLayout.
	view open.
] inPackagesMatching: 'Mondrian-*'.
\end{lstlisting}

This script generates an easy visualization that corresponds a MOShape class hierarchy depicted on \figref{MondrianExample}, where each node is a class, edges designate inheritance. In this simple example 400 objects of Mondrian were created and they received 12687 messages.

\begin{center}
   \begin{tabular}{|l||ccr|} \hline
	Class & Instances & Messages \\
	MOMorphPainterVisitor & 1 & 51	\\
	MORectangleShape & 2 & 1602	\\
	MOStraightLineShape & 1 & 296	\\
	MOTreeLayout & 1 & 536	\\
	ConcreteShapeVisitor & 49 & 98 \\
	MONode & 300 & 5693\\
	MOElementShapeProperties & 10 & 85\\
	MOViewRenderer & 1 & 292\\
	MOEdge & 24 & 3442\\
	MORoot & 6 & 548\\
	MOBrowser & 1 & 11\\
	MOCanvas & 1 & 9\\
	MOAnnouncer & 3 & 24\\
	Total & 400 & 12687 \\
   \end{tabular}
\end{center}

We get surprised with these result: Why 300 objects of MONode were created if "MOShape withAllSubclasses" only are 25 elements?. We search in the extend code and we could not find the reason. This simple anomalies brought us to follow many questions: Are 400 objects really needed? Where are used these objects? Are 12687 messages needed? Can we reduce the number of messages?.

\subsection{Using Tree Layout}

\largefig{}{1.0}{MondrianTreeLayout}{Mondrian Tree Layout}

In this section we visualize the following instruction using Tree Layout (\figref{MondrianTreeLayout}):
\begin{lstlisting}[language=Smalltalk]
|view|
Chaski profile: [
	view := MOViewRenderer new.
	view nodes: ChaskiLayout withAllSubclasses.
	]  inPackagesMatching: 'Mondrian-*'.
Chaski layout treeMessageLayout.
Chaski open.
\end{lstlisting}


In this context we can analyze the red message:
\begin{lstlisting}[language=Smalltalk]
defaultNodeShapeClass
"Return the default node shape class"
| classes |

classes := (self allSubclasses select: #isDefaultNodeShape).
classes ifEmpty: [ self error: 'No default shape class' ].

^ classes anyOne
\end{lstlisting}

This code clearly does a search twice during the execution, and the search is independent of the context because this method doesn't receive parameters and also doesn't use an instance variable. Clearly this is a method we can improve using cache.
\begin{lstlisting}[language=Smalltalk]
defaultNodeShapeClass
"Return the default node shape class"

| classes |
DefaultNodeShapeClass ifNotNil: [ ^ DefaultNodeShapeClass ].
classes := (self allSubclasses select: #isDefaultNodeShape).
classes ifEmpty: [ self error: 'No default shape class' ].

^ DefaultNodeShapeClass := classes anyOne.

\end{lstlisting}

\subsection{Using Sequence Layout}

\largefig{}{1.0}{MondrianSequenceLayout}{Sequence Tree Layout}
In this section we visualize the following instructions using Sequence Layout (\figref{}):
\begin{lstlisting}[language=Smalltalk]
|view|
view := MOViewRenderer new.
view nodes: ChaskiLayout withAllSubclasses.
Chaski profile: [
	view edgesFrom:#superclass.
	]  inPackagesMatching: 'Mondrian-*'.
Chaski layout treeMessageLayout.
Chaski open.
\end{lstlisting}

In this section we will examine \figref{Before1}. The first execution anomaly that we can found is in the section (A), where there are some objects that receive only one message in the execution. The following code correspond to these messages.

\begin{lstlisting}[language=Smalltalk]
MOGraphElement>>allNodesDo: aBlock
	"Evaluate aBlock all its children."
	self copy nodesDo: [ :each |
		aBlock value: each.
		each allNodesDo: aBlock ]
\end{lstlisting} 

This is a wierd code, because "self copy" do a shadow copy of the receiver node, and call to nodesDo: selector.

\begin{lstlisting}[language=Smalltalk]
MONode>>nodesDo: aBlock
	"Iterates over all the subnodes of the receiver."	
	nodes ifNil: [ ^ self ].
	nodes do: aBlock
\end{lstlisting} 

And this do something with the original subnodes, this is possible to see in the visualization, but the copy nodes do nothing after that because nobody save it's reference. This is clearly an issue  and it is consuming memory needlessly.

For the first execution anomaly, we refactor the ``allNodesDo:'' method: 
\begin{lstlisting}[language=Smalltalk]
MOGraphElement>>allNodesDo: aBlock
	"Evaluate aBlock all its children."
	self nodesDo: [ :each |
		aBlock value: each.
		each allNodesDo: aBlock ]
\end{lstlisting} 

\begin{center}
   \begin{tabular}{|l||ccr|} \hline
	Class & Instances & Messages \\
	MOMorphPainterVisitor & 1 & 51	\\
	MORectangleShape & 2 & 1602	\\
	MOStraightLineShape & 1 & 296	\\
	MOTreeLayout & 1 & 536	\\
	ConcreteShapeVisitor & 49 & 98 \\
	MONode & 25 & 5693\\
	MOElementShapeProperties & 10 & 91\\
	MOViewRenderer & 1 & 292\\
	MOEdge & 24 & 3442\\
	MORoot & 1 & 548\\
	MOBrowser & 1 & 11\\
	MOCanvas & 1 & 9\\
	MOAnnouncer & 3 & 24\\
	Total & 120 & 12696 \\
   \end{tabular}
\end{center}

\section{Discussion}\seclabel{discussion}

The large-scale sequence of messages makes the screen resolution not enough to show a lot of information,causing the emergence of scrolls that make the graphics difficult to understand. 
%Group the messages only by class and packages reduce the height of a visualization. However the big number of messages remains a problem.



\section{Related work}\seclabel{relatedwork}

Research into trace visualization has resulted in various techniques and tools.

%: % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\section{Conclusion}\seclabel{conclusion}

%\paragraph{Acknowledgment}
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %

\bibliographystyle{plain}
\bibliography{scg}

\end{document}

