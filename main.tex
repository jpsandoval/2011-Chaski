%%%%%%%%%%%%%
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
%\documentclass[runningheads]{llncs}
%\documentclass[10pt,letterpaper,twocolumn]{article}
\documentclass{sig-alternate}


% packages
\usepackage{xspace}
\usepackage{ifthen}
\usepackage{amsbsy}
\usepackage{amssymb}
\usepackage{balance}
\usepackage{booktabs}
\usepackage{graphicx}
\usepackage{multirow}
\usepackage{needspace}
\usepackage{microtype}
\usepackage{bold-extra}
\usepackage{subfigure}
\usepackage{wrapfig}


% constants
\newcommand{\Title}{Execution Blueprint: An Effective Visual Support to Monitor Software Execution}
\newcommand{\TitleShort}{\Title}
\newcommand{\Authors}{Juan Pablo Sandoval Alcocer, Alexandre Bergel}
\newcommand{\AuthorsShort}{J.P. Sandoval Alcocer, A. Bergel}

% references
\usepackage[colorlinks]{hyperref}
\usepackage[all]{hypcap}
\setcounter{tocdepth}{2}
\hypersetup{
	colorlinks=true,
	urlcolor=black,
	linkcolor=black,
	citecolor=black,
	plainpages=false,
	bookmarksopen=true,
	pdfauthor={\Authors},
	pdftitle={\Title}}

\def\chapterautorefname{Chapter}
\def\appendixautorefname{Appendix}
\def\sectionautorefname{Section}
\def\subsectionautorefname{Section}
\def\figureautorefname{Figure}
\def\tableautorefname{Table}
\def\listingautorefname{Listing}

% source code
\usepackage{xcolor}
\usepackage{textcomp}
\usepackage{listings}
\definecolor{source}{gray}{0.9}
\lstset{
	language={},
	% characters
	tabsize=3,
	upquote=true,
	escapechar={!},
	keepspaces=true,
	breaklines=true,
	alsoletter={\#:},
	breakautoindent=true,
	columns=fullflexible,
	showstringspaces=false,
	basicstyle=\footnotesize\sffamily,
	% background
	frame=single,
    framerule=0pt,
	backgroundcolor=\color{source},
	% numbering
	numbersep=5pt,
	numberstyle=\tiny,
	numberfirstline=true,
	% captioning
	captionpos=b,
	% formatting (html)
	moredelim=[is][\textbf]{<b>}{</b>},
	moredelim=[is][\textit]{<i>}{</i>},
	moredelim=[is][\color{red}\uwave]{<u>}{</u>},
	moredelim=[is][\color{red}\sout]{<del>}{</del>},
	moredelim=[is][\color{blue}\underline]{<ins>}{</ins>}}
\newcommand{\ct}{\lstinline[backgroundcolor=\color{white},basicstyle=\footnotesize\ttfamily]}
\newcommand{\lct}[1]{{\small\tt #1}}

% tikz
% \usepackage{tikz}
% \usetikzlibrary{matrix}
% \usetikzlibrary{arrows}
% \usetikzlibrary{external}
% \usetikzlibrary{positioning}
% \usetikzlibrary{shapes.multipart}
% 
% \tikzset{
% 	every picture/.style={semithick},
% 	every text node part/.style={align=center}}

% proof-reading
\usepackage{xcolor}
\usepackage[normalem]{ulem}
\newcommand{\ra}{$\rightarrow$}
\newcommand{\ugh}[1]{\textcolor{red}{\uwave{#1}}} % please rephrase
\newcommand{\ins}[1]{\textcolor{blue}{\uline{#1}}} % please insert
\newcommand{\del}[1]{\textcolor{red}{\sout{#1}}} % please delete
\newcommand{\chg}[2]{\textcolor{red}{\sout{#1}}{\ra}\textcolor{blue}{\uline{#2}}} % please change
\newcommand{\chk}[1]{\textcolor{ForestGreen}{#1}} % changed, please check

% comments \nb{label}{color}{text}
\newboolean{showcomments}
\setboolean{showcomments}{true}
\ifthenelse{\boolean{showcomments}}
	{\newcommand{\nb}[3]{
		{\colorbox{#2}{\bfseries\sffamily\scriptsize\textcolor{white}{#1}}}
		{\textcolor{#2}{\sf\small$\blacktriangleright$\textit{#3}$\blacktriangleleft$}}}
	 \newcommand{\version}{\emph{\scriptsize$-$Id$-$}}}
	{\newcommand{\nb}[2]{}
	 \newcommand{\version}{}}
\newcommand{\rev}[2]{\nb{Reviewer #1}{red}{#2}}
\newcommand{\ab}[1]{\nb{Alexandre}{blue}{#1}}
\newcommand{\vp}[1]{\nb{Vanessa}{orange}{#1}}
\newcommand{\jp}[1]{\nb{Juan Pablo}{green}{#1}}

% graphics: \fig{position}{percentage-width}{filename}{caption}
\DeclareGraphicsExtensions{.png,.jpg,.pdf,.eps,.gif}
\graphicspath{{figures/}}
\newcommand{\fig}[4]{
	\begin{figure}[#1]
		\centering
		\includegraphics[width=#2\textwidth]{#3}
		\caption{\label{fig:#3}#4}
	\end{figure}}

\newcommand{\largefig}[4]{
	\begin{figure*}[#1]
		\centering
		\includegraphics[width=#2\textwidth]{#3}
		\caption{\label{fig:#3}#4}
	\end{figure*}}
	
\newcommand{\wrapfig}[5]{	
\begin{wrapfigure}{#1}{#2\textwidth}
  \begin{center}
    \includegraphics[width=#3\textwidth]{#4}
  \end{center}
  \caption{\label{fig:#4}#5}
\end{wrapfigure}}

% abbreviations
\newcommand{\ie}{\emph{i.e.,}\xspace}
\newcommand{\eg}{\emph{e.g.,}\xspace}
\newcommand{\etc}{\emph{etc.}\xspace}
\newcommand{\etal}{\emph{et al.}\xspace}

% lists
\newenvironment{bullets}[0]
	{\begin{itemize}}
	{\end{itemize}}

\newcommand{\seclabel}[1]{\label{sec:#1}}
\newcommand{\figlabel}[1]{\label{fig:#1}}
\newcommand{\figref}[1]{Figure~\ref{fig:#1}}
\newcommand{\secref}[1]{Section~\ref{sec:#1}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% adding smalltalk listing %%%%%%%%%%%%%%%%%%%5
\lstdefinelanguage{Smalltalk}{
  morekeywords={true,false,self,super,nil},
  sensitive=true,
  morecomment=[s]{"}{"},
  morestring=[d]',
  style=SmalltalkStyle
}
\lstdefinestyle{SmalltalkStyle}{
  literate={:=}{{$\gets$}}1{^}{{$\uparrow$}}1
} 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% adding smalltalk listing %%%%%%%%%%%%%%%%%%%5

%Specialized macros
\newcommand{\hapao}{Hapao\xspace}
\newcommand{\Hapao}{Hapao\xspace}
\pagenumbering{arabic}

\begin{document}

\title{\Title}
%\titlerunning{\TitleShort}

\author{\Authors\\[3mm]
Department of Computer Science (DCC)\\ University of Chile, Santiago, Chile\\[1 ex]
} 
%\authorrunning{\AuthorsShort}

\maketitle

\emph{This paper makes use of colored figures. Though colors are not mandatory for full understanding, we recommend  the use of a colored printout.}

\begin{abstract}
%	What's the problem.
%	Why is the problem a problem?
%	What's the surprising idea?
%	What's the consequence?

Understanding the behavior of software is one essential task of the software life cycle, especially when maintenance activities have to be performed. One has to analyze the code, the documentation or any other device before making any changes therefore it becomes a difficult task and time consuming.

Our goal is to show a visualization that represents the interaction of objects involved in the execution which can help developers gain a better understanding of the software execution. The large number of objects involved in execution represents a major challenge.

Chaski is a tool to address this problem of understanding by visualizing the execution of an object oriented program. Execution blueprint shows the interaction between objects through messages exchanged between them, in the order they occur. \ab{Say more about the visualization}. This visualization helps to: understand the current behavior of the software, find candidates for refactoring and optimization, show dependencies and relations, among others.


\end{abstract}

%: % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %

\section{Introduction}\seclabel{introduction}

The use of highly reflective dynamic languages can make seemingly simple questions(how 2 or more packages interact? What kinds are dependent to a certain class? When exactly this method is invoked?)difficult to answer if we just analyze the source code, documentation or any other appliance design.

To answer these questions among others and to improve the process of understanding, it is necessary to make a dynamic analysis, or analysis of data retrieved from the execution of a program.

In this context, we propose a visualization of the execution of an object oriented program, showing the interaction between objects through messages exchanged between them, in the order they occur. While understanding the overall behavior of the system is ideal, this visualization was intended to be used by objectives, in other words, to analyze portions of the application that really interest us to achieve an objective.

The purpose of this visualization is to help: understand the current behavior of the software, find candidates for refactoring and optimization, show dependencies and relations, among others.

%: % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\section{Execution Blueprint}\seclabel{executionBlueprint}

\subsection{In a nutshell}

In this section we'll discuss the visualization shown in Figure 1.

\largefig{}{1.0}{MondrianDependence}{How packages/class interact in the execution? (mondrian)}


In figure 1 we can distinguish two types of components; the classifiers: package, class, object which are identified by the colors blue, red, yellow  respectively; and the messages, which are shown with a gray color by default. Depending on what we want to analyze in the visualization, we can set different colors to the messages based on a criteria. In the case of Figure 1, the magenta color was established for "initialize" messages.

The visualization shows the interaction between objects, classes and packages (classifiers) through messages sent or received by them, where the messages are vertically aligned with the component receiving the message and placed horizontally in the order in which these messages were received.

The edges are an important factor in allowing the visualization to link two messages, in the case of Figure 1 the axes represent dependency between messages, being the message at the left the one that invokes to the message at the right.

All this allows to determine which object is the one that receives more messages, which object needs to communicate with objects from other packages, which objects are instantiated at runtime (magenta messages) and how many instances of a particular class participate in the execution.

%=========
\subsection{Layout}
The essence of "layout" are the messages and the chronological order in which these(messages) occur. And provide clasifiers in order to group the messages.As seen in the example in Figure 1. the messages are grouped first by class package and finally by subject, note that some messages are not directly associated with an object but with a class, meaning that the receiver of the message is the same class (a class method).

This classification or grouping of posts may vary depending on what one may want to analyze. For example in Figure 3 messages are just grouped simply by object, in order to analyze the dependency between objects.

While the messages are sorted horizontally in chronological order, the other components (package, class, object) are sorted vertically by number of messages that has been sent, in this sense the component that sends more messages are located above.

The relationships between messages is an important factor(edges) in the visualization.We consider two types of relationships between messages.

\begin{itemize}
\item Dependency .- where a message is related to the message from which it was invoked (Figure 1).
\item Sequence.- where a message is simply associated with another in the order they were executed. (Figure 3).
\end{itemize}
%=========
\subsection{Patterns}
\jp{ esta seccion se baso en el paper Execution Patterns in Object-Oriented Visualization que esta en el directorio}

Execution BluePrint allows classifying repetitive behavior(patterns) to help the developer to have a better understanding of the behavior of software and to reduce the analysis time of the visualization.

\begin{itemize}
\item Identity Behavior.- When two or more sections of the visualization have identical behavior(same sequence of messages) and there is a perfect match between objects and messages. Which implies that the messages of each section were transmitted and received by the same objects.
\item Class Identity Behavior.- When two or more sections of the visualization have identical behavior(same sequence of messages) but the messages of each section	 were sent and received by different instances from the same class.(Figure 2).
\end{itemize}

In fact it is possible to find more patterns but for specific domains. That is the case of figure 3, in which the behavior of the execution of a Test Suite is analyzed. Note that one of the important features of a suite of tests is that they should be independent of each other: the failure of one test should not cause an avalanche of failures of other tests that depend upon it, nor should the order in which the tests are run matter. Performing setUp before each test and tearDown afterwards helps to reinforce this independence.


\largefig{}{1.0}{ChaskiPreview11}{Finding patterns in the execution (Glamour)}
\largefig{}{1.0}{ChaskiPreview8}{Visualizing a Test Suite execution (RBSmallDictionaryTest buildSuite run)}
%: % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\section{Case Study}\seclabel{case study}

\subsection{Mondrian}

We will use Mondrian to demonstrate how " Execution BluePrint" visualization is useful to understand the current behavior of the software and find candidates for refactoring and optimization. To which we will address the visualization for the following code execution (Figure 4):
\begin{lstlisting}[language=Smalltalk]
	...
	view  :=  MOViewRenderer title: 'Mondrian View Renderer'.
	view nodes: subclasses.
	view edgesFrom: #superclass.
	view treeLayout.
	...
\end{lstlisting}


\subsection{Execution anomalies}

In this section we will examine Figure 4, which groups messages only for package and class. This type of grouping is useful to detect the pattern " Class Behavior Identity" more easily .

In the display you can see the existence of behavior repeated in several places, we  will next analyze the sequence of messages in this box.
Se encontro al metodo responsable de provocar dicho comportamiento:
It was found the method responsible for causing this behavior:

\begin{lstlisting}[language=Smalltalk]
MOShape class>>defaultNodeShapeClass
		"Return the default node shape class"
		| classes |
		classes := (self allSubclasses select: #isDefaultNodeShape).
		classes ifEmpty: [ self error: 'No default shape class' ].
		^ classes anyOne.
\end{lstlisting} 

The method defaultNodeShapeClass has the function to search through a MOShape subclasses one class established by default. Through the method "isDefaultNodeShape" shown below.

\begin{lstlisting}[language=Smalltalk]
MORectangleShape class>>isDefaultNodeShape
	^ true
\end{lstlisting} 

\largefig{}{1.0}{Mondrian1}{Before Improvement}
\subsection{Improvement}

Based on the above analysis we can deduce that it is not necessary to search twice because it could not be changed or set by default to a subclass of MOShape at runtime. That is, the result of the search will always be the same during the execution.

Therefore, the code was improved using Cache:

\begin{lstlisting}[language=Smalltalk]
MOShape class>>defaultNodeShapeClass
	"Return the default node shape class"
	| classes |
	"Cache"
	DefaultNodeShapeClass ifNotNil:[^DefaultNodeShapeClass].
	classes := (self allSubclasses select: #isDefaultNodeShape).
	classes ifEmpty: [ self error: 'No default shape class' ].
	"Cache"
	^ DefaultNodeShapeClass := classes anyOne.
\end{lstlisting} 


\jp{**No se si poner lo que esta debajo a este comentario , parece mucho detalle}
And we established a method for removing the Cache:
\begin{lstlisting}[language=Smalltalk]
MOShape class>>resetCache
	DefaultNodeShapeClass :=nil.
\end{lstlisting} 
Since it is possible for someone to set some other default MOShape before running the application, the cache is removed before Mondrian carries out any visualization:
\begin{lstlisting}[language=Smalltalk]
MOViewRenderer>>initialize
	MOShape resetCache.
	...
\end{lstlisting} 
After we made these changes, the execution is shown as follows in Figure 5.
\jp{**}

\largefig{}{1.0}{Mondrian2}{After Improvement}



%: % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\section{Managing the scalability}\seclabel{scalability}

So like a lot of objects are created when executing an object-oriented program,  so much larger the number of messages that are sent between objects, making the visualization extremely large. The filters in chaski try to display messages that meet a certain condition allowing a smaller view and most importantly, making  possible to analyze only the messages that interest us.

%: % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\section{Discussion}\seclabel{discussion}
The large-scale sequence of messages makes the screen resolution not enough to show a lot of information,causing the emergence of scrolls that make the graphics difficult to understand\ab{This is an important point, but this has to come later on in the paper. Maybe in the discussion session}.

%: % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\section{Implementation}\seclabel{implementation}

\subsection{Chaski}


%: % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\section{Related work}\seclabel{relatedwork}


%: % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %

\section{Conclusion}\seclabel{conclusion}

%\paragraph{Acknowledgment}
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %

\bibliographystyle{plain}
\bibliography{scg}

\end{document}

