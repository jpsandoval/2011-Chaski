%%%%%%%%%%%%%
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
%\documentclass[runningheads]{llncs}
%\documentclass[10pt,letterpaper,twocolumn]{article}
%\documentclass{sig-alternate}
\documentclass[10pt, conference, compsocconf]{IEEEtran}



% packages
\usepackage{xspace}
\usepackage{ifthen}
\usepackage{amsbsy}
\usepackage{amssymb}
\usepackage{balance}
\usepackage{booktabs}
\usepackage{graphicx}
\usepackage{multirow}
\usepackage{needspace}
\usepackage{microtype}
\usepackage{bold-extra}
\usepackage{subfigure}
\usepackage{wrapfig}


% constants
\newcommand{\Title}{Execution Blueprint: An Effective Visual Support to Monitor Software Execution}
\newcommand{\TitleShort}{\Title}
\newcommand{\Authors}{Juan Pablo Sandoval Alcocer, Alexandre Bergel}
\newcommand{\AuthorsShort}{J.P. Sandoval Alcocer, A. Bergel}

% references
\usepackage[colorlinks]{hyperref}
\usepackage[all]{hypcap}
\setcounter{tocdepth}{2}
\hypersetup{
	colorlinks=true,
	urlcolor=black,
	linkcolor=black,
	citecolor=black,
	plainpages=false,
	bookmarksopen=true,
	pdfauthor={\Authors},
	pdftitle={\Title}}

\def\chapterautorefname{Chapter}
\def\appendixautorefname{Appendix}
\def\sectionautorefname{Section}
\def\subsectionautorefname{Section}
\def\figureautorefname{Figure}
\def\tableautorefname{Table}
\def\listingautorefname{Listing}

% source code
\usepackage{xcolor}
\usepackage{textcomp}
\usepackage{listings}
\definecolor{source}{gray}{0.9}
\lstset{
	language={},
	% characters
	tabsize=3,
	upquote=true,
	escapechar={!},
	keepspaces=true,
	breaklines=true,
	alsoletter={\#:},
	breakautoindent=true,
	columns=fullflexible,
	showstringspaces=false,
	basicstyle=\footnotesize\sffamily,
	% background
	frame=single,
    framerule=0pt,
	backgroundcolor=\color{source},
	% numbering
	numbersep=5pt,
	numberstyle=\tiny,
	numberfirstline=true,
	% captioning
	captionpos=b,
	% formatting (html)
	moredelim=[is][\textbf]{<b>}{</b>},
	moredelim=[is][\textit]{<i>}{</i>},
	moredelim=[is][\color{red}\uwave]{<u>}{</u>},
	moredelim=[is][\color{red}\sout]{<del>}{</del>},
	moredelim=[is][\color{blue}\underline]{<ins>}{</ins>}}
\newcommand{\ct}{\lstinline[backgroundcolor=\color{white},basicstyle=\footnotesize\ttfamily]}
\newcommand{\lct}[1]{{\small\tt #1}}

% tikz
% \usepackage{tikz}
% \usetikzlibrary{matrix}
% \usetikzlibrary{arrows}
% \usetikzlibrary{external}
% \usetikzlibrary{positioning}
% \usetikzlibrary{shapes.multipart}
% 
% \tikzset{
% 	every picture/.style={semithick},
% 	every text node part/.style={align=center}}

% proof-reading
\usepackage{xcolor}
\usepackage[normalem]{ulem}
\newcommand{\ra}{$\rightarrow$}
\newcommand{\ugh}[1]{\textcolor{red}{\uwave{#1}}} % please rephrase
\newcommand{\ins}[1]{\textcolor{blue}{\uline{#1}}} % please insert
\newcommand{\del}[1]{\textcolor{red}{\sout{#1}}} % please delete
\newcommand{\chg}[2]{\textcolor{red}{\sout{#1}}{\ra}\textcolor{blue}{\uline{#2}}} % please change
\newcommand{\chk}[1]{\textcolor{ForestGreen}{#1}} % changed, please check

% comments \nb{label}{color}{text}
\newboolean{showcomments}
\setboolean{showcomments}{true}
\ifthenelse{\boolean{showcomments}}
	{\newcommand{\nb}[3]{
		{\colorbox{#2}{\bfseries\sffamily\scriptsize\textcolor{white}{#1}}}
		{\textcolor{#2}{\sf\small$\blacktriangleright$\textit{#3}$\blacktriangleleft$}}}
	 \newcommand{\version}{\emph{\scriptsize$-$Id$-$}}}
	{\newcommand{\nb}[2]{}
	 \newcommand{\version}{}}
\newcommand{\rev}[2]{\nb{Reviewer #1}{red}{#2}}
\newcommand{\ab}[1]{\nb{Alexandre}{blue}{#1}}
\newcommand{\vp}[1]{\nb{Vanessa}{orange}{#1}}
\newcommand{\jp}[1]{\nb{Juan Pablo}{green}{#1}}

% graphics: \fig{position}{percentage-width}{filename}{caption}
\DeclareGraphicsExtensions{.png,.jpg,.pdf,.eps,.gif}
\graphicspath{{figures/}}
\newcommand{\fig}[4]{
	\begin{figure}[#1]
		\centering
		\includegraphics[width=#2\textwidth]{#3}
		\caption{\label{fig:#3}#4}
	\end{figure}}

\newcommand{\largefig}[4]{
	\begin{figure*}[#1]
		\centering
		\includegraphics[width=#2\textwidth]{#3}
		\caption{\label{fig:#3}#4}
	\end{figure*}}
	
\newcommand{\wrapfig}[5]{	
\begin{wrapfigure}{#1}{#2\textwidth}
  \begin{center}
    \includegraphics[width=#3\textwidth]{#4}
  \end{center}
  \caption{\label{fig:#4}#5}
\end{wrapfigure}}
	
% abbreviations
\newcommand{\ie}{\emph{i.e.,}\xspace}
\newcommand{\eg}{\emph{e.g.,}\xspace}
\newcommand{\etc}{\emph{etc.}\xspace}
\newcommand{\etal}{\emph{et al.}\xspace}

% lists
\newenvironment{bullets}[0]
	{\begin{itemize}}
	{\end{itemize}}

\newcommand{\seclabel}[1]{\label{sec:#1}}
\newcommand{\figlabel}[1]{\label{fig:#1}}
\newcommand{\figref}[1]{Figure~\ref{fig:#1}}
\newcommand{\secref}[1]{Section~\ref{sec:#1}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% adding smalltalk listing %%%%%%%%%%%%%%%%%%%5
\lstdefinelanguage{Smalltalk}{
  morekeywords={true,false,self,super,nil},
  sensitive=true,
  morecomment=[s]{"}{"},
  morestring=[d]',
  style=SmalltalkStyle
}
\lstdefinestyle{SmalltalkStyle}{
  literate={:=}{{$\gets$}}1{^}{{$\uparrow$}}1
} 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% adding smalltalk listing %%%%%%%%%%%%%%%%%%%5

%Specialized macros
\newcommand{\hapao}{Hapao\xspace}
\newcommand{\Hapao}{Hapao\xspace}
\pagenumbering{arabic}

\begin{document}

\title{\Title}
%\titlerunning{\TitleShort}

\author{\Authors\\[3mm]
Department of Computer Science (DCC)\\ University of Chile, Santiago, Chile\\[1 ex]
} 
%\authorrunning{\AuthorsShort}

\maketitle

%\emph{This paper makes use of colored figures. Though colors are not mandatory for full understanding, we recommend  the use of a colored printout.}

%We currently know little about the execution of software in general. Most of the tools we use to construct software focus on static abstractions (class and method definitions) instead of message sending. Little options are offered to developers to fully understand how objects interact. 
%As a consequence, developers have to resort to ad-hoc solutions to identify redundant computation, excessive memory consumption and odd interactions. 


\begin{abstract}
%	What's the problem.
%	Why is the problem a problem?
%	What's the surprising idea?
%	What's the consequence?

%Understanding the behavior of software is an essential task of the software life cycle, especially when performance monitoring activities have to be maintained.
Traditional code profilers and debuggers for object-oriented programming languages essentially consider a software as a bunch of classes and methods, defined in textual files. These abstractions poorly match with what a computation is made of: objects sending and receiving messages. A severe consequence is that developers often turn to ad-hoc solutions to identify redundant computation, excessive memory consumption and odd object interactions.  %understand better the execution.

We propose \emph{execution blueprints} to visually identify execution patterns. Our blueprints offer intuitive execution representations, useful to identify abnormal execution. We used polymetric views~\cite{Lanz03d} as the visual representation for our blueprint.  
Adequate combinations of layouts and coloring reveals certain execution anomalies and performances issues.

Thanks to our framework Chaski, we were able to find a number of serious defect in an application written in the Pharo programming language.

%Our goal is to show a visualization that represents the interaction of objects involved in the execution which can help developers gain a better understanding of the software execution. The large number of objects involved in execution represents a major challenge.
%
%Chaski is a tool to address this problem of understanding by visualizing the execution of an object oriented program. Execution blueprint shows the interaction between objects through messages exchanged between them, in the order they occur. \ab{Say more about the visualization}. This visualization helps to: understand the current behavior of the software, find candidates for refactoring and optimization, show dependencies and relations, among others.
\end{abstract}

%: % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %

\section{Introduction}\seclabel{introduction}

%Dynamic analysis 

Data-mining program execution traces is known to be difficult. Exploring a real-world list of sequence execution events cannot be effective without addressing scalability issues~\cite{Kuhn06c} and supporting expressive queries~\cite{Zaid05a}. 

Visualizing execution trace has recently been identified as a promising approach to manage scalability and pattern recognition~\cite{Maoz11a,Zaid05a,Reis07a}. %Numerous approaches have been proposed in that respect. 

Maletic \etal~\cite{Male02a} state ``no single software visualization tool can address all software engineering tasks simultaneously.'' However, when we retrospectively look at the existing trace visualization engines, it is startling to see that the great majority are rigid in the visual representation they support. Visualizations are usually targeted at identifying one family of patterns.% and the engine behind is hardly extendable. 

Consider circular bundle view proposed by Cornelissen \etal~\cite{Corn08a}. Structural program elements are on the circumference of a circle and runtime invocations are bundled based on B-spline curves~\cite{Holt06b}. Whereas the visualization is adjustable (\eg high-level structural entities may be collapsed) the range of discoverable patterns remains constant. The situation is similar with other visualization engines, including TraceVis~\cite{Deel07a} and Tracer~\cite{Maoz11a}.

 

%~\cite{Male02a}
%Tasks -- why is the visualization needed?
%Audience -- who will use the visualization?
%Target -- what is the data source to represent?
%Representation -- how to represent it?
%Medium -- where to represent the visualization?

We address this problem by proposing a framework for \emph{execution blueprints}, a blueprint being a tailored visual trace representation. An execution blueprint aims at identifying problematic execution patterns. From a given execution trace of an object-oriented application, an execution blueprint visualizes the exchanged messages and the object involved in the profiled computation.

A blueprint is parametrized with a layout and a color map. The layout assigns to each message a physical position on the screen and the color map assigns a color against some properties of the message.

All our experiments and implementation effort have been carried out in Pharo\footnote{\url{http://pharo-project.org}}, a Smalltalk-dialect programming language. 
We designed and implemented Chaski, a framework for execution trace visualization. Chaski allows one to easily define a new blueprint with a customized layout and color map. A 5 minutes screencast is available online on \url{http://tinyurl.com/executionBlueprint}.

This paper is structured as follows. 
\secref{executionBlueprints} presents two execution blueprints.
\secref{framework} briefly illustrates an instantiation of the Chaski framework.
\secref{caseStudy} employs the blueprints to identify execution anomalies in an application large of 200 classes.
\secref{conclusion} concludes and sketches our future work.


%The use of highly reflective dynamic languages can make seemingly simple questions(how 2 or more packages interact? What kinds are dependent to a certain class? When exactly this method is invoked?)difficult to answer if we just analyze the source code, documentation or any other appliance design.
%
%To answer these questions among others and to improve the process of understanding, it is necessary to make a dynamic analysis, or analysis of data retrieved from the execution of a program.
%
%In this context, we propose a visualization of the execution of an object oriented program, showing the interaction between objects through messages exchanged between them, in the order they occur. While understanding the overall behavior of the system is ideal, this visualization was intended to be used by objectives, in other words, to analyze portions of the application that really interest us to achieve an objective.
%
%The purpose of this visualization is to help: understand the current behavior of the software, find candidates for refactoring and optimization, show dependencies and relations, among others.
%

%: % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\section{Execution Blueprints} \seclabel{executionBlueprints}

%We define \emph{execution blueprints} as a visual representation of an execution trace. 
%
%In order for our approach to be effective, the execution trace has to contains the names of messages that are sent and an unique identification of the object receiver. 
%
%An execution trace is a structure in which the profiled information is stored\ab{Give a reference, I guess this is not your definition}. Execution blueprint is a post mortem analysis, implying that the software execution has terminated. 
%
%A computation in an object-oriented language is exercised with objects interacting by sending messages to themselves. 

We proposes two execution blueprints, a \emph{message-centric blueprint} that emphasizes on the messages sent between objects and an \emph{object-centric blueprint} to focus on the objects instead.

A blueprint represents messages and objects as small colored boxes. Edges between two boxes represents the sequence between messages. As discussed below, the differences between the two blueprints is essentially based on the color map and the layout.

%We illustrate the blueprint on contrived but representative examples. \secref{caseStudy} will study their applications on a large case study.

%\subsection{Chaski objectives}
%
%
%The main purpose of Chaski is to help programmers find problems or anomalies on the application using execution traces. We found that each visualizations can help to detect a limited number of problems. In the following section we present the Chaski layouts and their purpose.
%
%Interesting problems that visualization can help to solve are: understand the current behavior of the software, find candidates for refactoring and optimization, show dependencies and relationship, among others.

%============1

\subsection{Message-centric execution blueprint}

\fig{}{0.48}{MessageCentricBlueprint}{Message-centric execution blueprint}

\paragraph{Description}

The message-centric blueprint renders messages as boxes and execution sequence as edges. \figref{MessageCentricBlueprint} depicts a blueprint obtained from a program execution. The blueprint is structured as a tree layout: a message directly sends its message children in a sequential fashion. 

The root Message 1 is the first message sent by the profiled code. The execution of the method associated to this message sends Message 2. The ordering of the sequence is deep-first. We numbered the ordering of the message for the first 8 messages. 

All the messages are colored in grey in the initial rendering. Messages get colored by mouse clicking on a particular one. 
Coloring allows for a comparison of messages. The programmer has clicked on Message 2, which is indicated with a red border on \figref{MessageCentricBlueprint}. 

Clicking on a node triggers a structure pattern helps identify identify similar executions. The message structure below Message 2 is searched over the complete trace. Two instances of this structure is found, indicated with \ct{A} and \ct{B}.

Differences between the matched structures is indicated with yellow and red. A yellow message indicates that the sibling nodes in the matched structures have a different receiver. For example, the objects that receives Messages 2, A and B are different instances of the same class. A red message indicates that the sibling messages were executed on the same object. This is the case of Message 4, and the two red messages below \ct{A} and \ct{B}. 


%Colors help us to find identity behavior \ab{What is an identify behavior?}. To find identity behavior we only need to select a sequence of messages (sub-tree) and automatically all identity sequence of messages (sub-tree) are colored with red and yellow. The colors are set with the following criteria: the red boxes are messages that: i) they have the same selector ii) they are received by the same object; and the yellow boxes are messages that: i) they have the same selector ii) the receivers of these messages are instances of the same class.

\paragraph{Interpretation}
The computation invokes the same messages on 3 different objects. The interesting point here is the presence of the red nodes, which are 3 messages sent to the same group of objects. Identifying that a particular object receives several time the same messages may indicate a candidate for inserting a memoization. 

%\ab{What is the code of the method invoked with Message 1?}
%\jp{the method is :}
%\begin{lstlisting}[language=Smalltalk]
%MOViewRenderer>>nodes: aCollection using: aShape 
%| nodes newNode |
%self assert: [ aCollection isCollection ] description: 'A collection should be provided, else use #node: instead'.
%nodes := aCollection collect: 
%	[ :anEntity | 
%	newNode := MONode new.
%	newNode model: anEntity.
%	newNode shape: aShape.
%	newNode setAnnouncer: announcer.
%	self root addNode: newNode.
%	newNode ].
%self resetDefaults.
%^ nodes
%\end{lstlisting}



%This blueprint helps us to find identity behavior, for example in \figref{MessageCentricLayout} we can see all sent messages in an execution, the root message or event message is the responsible of invoking all other messages(A).  Note that there are 5 sub-tree structure like, but only 3 of them are painted with colors red and yellow(B), because these sub-trees have identity behavior.

%Finding identity behavior helps us to detect possible points where we can apply a cache. For example, red messages cause the same sequence of messages and they are received by the same object. The cache stores data so that future invocation of a same method for that data can be retrieved faster.

%\paragraph{Interaction}
%
%The trigger to search identity behavior is a click in the root message of a sub-tree. Also we can press a right click in any message to inspect the method associated with the message.

%============
\subsection{Object-centric execution blueprint}

\fig{}{0.4}{ObjectCentricBlueprint}{Object-centric execution blueprint}

\paragraph{Description}
The object-centric execution blueprint describes the interaction occurring between objects. It renders objects and the messages they received as small colored boxes (\figref{ObjectCentricBlueprint}). The blueprint is composed of two parts.

The left-hand side presents the structure of the analyzed software. The packages involved in the trace are blue boxes (only one package is represented on the figure). 
Classes are represented as red boxes and are positioned on the right hand side of the package in which they are defined. Three classes, \ct{C1}, \ct{C2}, \ct{C3}, are involved in the trace. Objects, represented as yellow boxes, are located at the right-hand side of the class for which they are instances of. \ct{C1} and \ct{C2} have only one instance each, \ct{O1} and \ct{O2}, respectively. The class \ct{C3} has five instances.

Messages are located in a large matrix. A message $m$ is at a position $(i,o)$ where $i$ the index of the message in the trace and $o$ is the object that received $m$. Message \ct{m1} is the first message, received by \ct{O1}. Executing the method that corresponds to \ct{m1} sends the message \ct{m2} to one of the instance of \ct{C3}. 

Packages, classes and objects are vertically sorted along the number of messages they have sent. A component that sends more messages than its siblings is located above. For example, the object \ct{O1} receives the message \ct{m1}, itself sending 7 messages. It is therefore placed at the top of the blueprint. 

\paragraph{Interpretation}
We see that \ct{m1} performs iterates over three instances of \ct{C3}. It then executes 4 times the same method on the object \ct{C2}. Each of these 4 calls  executes a method on an instance of \ct{C3}.


%This layout distinguishes three types of components: classifiers, messages and edges (\figref{ObjectCentricLayout}). The classifiers are displayed as blue, red and yellow boxes that represent a package, class and object respectively(A). The gray boxes represent messages(B), and the edges link pairs of messages where a message is related to the message from which it was invoked.
%Classifiers are displayed as a composition. Note that in the \figref{Demo} the packages are composed by its classes and each class is composed by the objects that were instantiated from it (E).
%The messages are vertically aligned with the component receiving the message(D), and placed horizontally in the order in which these messages are received(timeline).
%
%\paragraph{Interpretation}
%
%This blueprint shows how many objects are in the execution, the messages that they received and the interaction between objects through messages exchanged between them, in the order they occur.
%
%
%\paragraph{Interaction}
%Also we can press a right click in any message to inspect the method associated with the message.

%============1

%: % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %

\section{The Chaski Framework}\seclabel{framework}

The two object-centric and message-centric blueprints are two instances of Chaski, our framework to visualize object-oriented execution traces. 
Chaski offers a small domain-specific language to customize the visualization. As a brief illustration, we will define the execution mural blueprint as proposed by Jerding and Stasko~\cite{Jerd98a}.

\fig{}{0.5}{ExecutionMuralDemo}{Execution Mural}

The Execution Mural visualization shows time on the horizontal axis and messages passed between classes in a program on the vertical (\figref{ExecutionMuralDemo}). The classes are on the vertical axis, and each message is a vertical line wide of 1 pixel from the source to the destination class.

The blueprint requires about 30 lines of Pharo code. First, the abstract class \ct{AbstractBlueprint} has to be subclassed:

\begin{lstlisting}[]
AbstractBlueprint subclass: #ExecutionMuralBlueprint.
\end{lstlisting}

The method \ct{doExecute:} has then to be overridden to specify the position of the messages, their color, and their length:

\begin{lstlisting}[]
ExecutionMuralBlueprint>>doExecute: profiledInformation
	| classes messages xo yo  from to |
	<b>"All the classes and messages involved in the profiling"</b>
	classes := profiledInformation allClasses.
	messages := profiledInformation allReceivedMessages.
	
	<b>"Positioning classes on the left hand side"</b>
	xo := gap. yo := gap.
	classes do: [ :class | 
		class moNode x: xo.   
		class moNode y: yo.
		yo := yo + defaultClassHeight. ].
		
	<b>"Positioning messages on the right hand side"</b>
	xo := defaultClassWidth + (gap*2).
	messages do: [ :m | 
		m sender ifNotNil: [
			from  := m sender  cclass moNode y.
			to    := m receiver cclass moNode y.
			m moNode y: (from min: to).
			m moNode x: xo.
			xo := xo+defaultMessageWidth  ] ].
	
	<b>"Adding the element in the visualization"</b>
	view chaskiShape 
		"width:  defaultClassWidth ;
		height: defaultClassHeight ;"
		text:     [ : class|  class className ].
	view nodes: classes.
	view chaskiShape 
		"width:  defaultMessageWidth;"
		height:  [ : message   | self messageHeight: message ] .
	view nodes: messages.
	
	<b>"Defining the coloring"</b>
	colorMap paint: classes  with: Color white.
	colorMap paint: messages with: Color gray.
\end{lstlisting}

The size of a message is computed as follows:
\begin{lstlisting}[]
ExecutionMuralBlueprint>>messageHeight: message
	| from to |
	message sender ifNil: [ ^ 0]. 
	from  :=  (message sender  cclass moNode y).
	to       :=  (message receiver cclass moNode y).
	^ (from - to) abs + defaultClassHeight .
\end{lstlisting}

The trace generation and the visualization is obtained with:

\begin{lstlisting}[]
ExecutionMuralBlueprint viewProfile:[
	<i>"Example code"
	| view |
	view := MOViewRenderer new.
	view nodes: MOGraphElement withAllSubclasses.
	view edgesFrom: #superclass.</i>
] inPackagesMatching: <i>'Mondrian-*'</i>.
\end{lstlisting}

Italic portion corresponds to an example.


%: % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %

\section{Case of Study}\seclabel{caseStudy}

We used the execution blueprint to analyze Mondrian, an agile visualization engine. Mondrian is actually used to render the trace visualization. We used Chaski and Mondrian to visualize execution traces of Mondrian.

Mondrian renders an arbitrary domain by constructing a node for each domain element and draw edges to indicate relations between two domain elements. Thanks to our blueprints, we identified two deficiencies in Mondrian. 

%In this section we show how Chaski visualizations help to improve the performance of Mondrian.
%For this we use this Mondrian script as an example:
%\begin{lstlisting}[language=Smalltalk]
%Chaski  profile:[
%	view := MOViewRenderer new.
%	|view|
%	view nodes: MOShape withAllSubclasses.
%	view edgesFrom: #superclass.
%	view treeLayout.
%	view open.
%] inPackagesMatching: 'Mondrian-*'.
%\end{lstlisting}
%
%This script generates an easy visualization that corresponds a MOShape class hierarchy depicted on \figref{MondrianExample}, where each node is a class, edges designate inheritance. In this simple example 400 objects of Mondrian were created and they received 12687 messages.
%
%\begin{center}
%   \begin{tabular}{|l||ccr|} \hline
%	Class & Instances & Messages \\
%	MOMorphPainterVisitor & 1 & 51	\\
%	MORectangleShape & 2 & 1602	\\
%	MOStraightLineShape & 1 & 296	\\
%	MOTreeLayout & 1 & 536	\\
%	ConcreteShapeVisitor & 49 & 98 \\
%	MONode & 300 & 5693\\
%	MOElementShapeProperties & 10 & 85\\
%	MOViewRenderer & 1 & 292\\
%	MOEdge & 24 & 3442\\
%	MORoot & 6 & 548\\
%	MOBrowser & 1 & 11\\
%	MOCanvas & 1 & 9\\
%	MOAnnouncer & 3 & 24\\
%	Total & 400 & 12687 \\
%   \end{tabular}
%\end{center}

\subsection{Execution deficiency}

We noticed that Mondrian was consuming an excessive amount of memory. This was perceived from frequent triggers of the garbage collector. In Pharo the garbage collector operates by ``stopping the world'', making the application run slower than expected.

By running our execution blueprint, we identified that 300 instances of the class \ct{MONode} were produced, whereas the visualization was showing only 25. The problem we now face is threefold:  understand why many more objects were created, identify unnecessary objects and remove their creation if possible.
The following sections briefly describes how the execution blueprint helped us to solve this performance issue.



%We get surprised with these result: Why 300 objects of MONode were created if "MOShape withAllSubclasses" only are 25 elements?. We search in the extend code and we could not find the reason. This simple anomalies brought us to follow many questions: Are 400 objects really needed? Where are used these objects? Are 12687 messages needed? Can we reduce the number of messages?.

\subsection{Introducing a memoization cache}\seclabel{memoization}

\largefig{}{1.0}{MessageCentricBlueprintMondrian}{Identifying method candidate for a memoization}

\figref{MessageCentricBlueprintMondrian} shows a message-centric blueprint for our execution of Mondrian. We see that two groups of messages that we qualify as ``flying saucers''~\cite{Lanz03d}, marked with \ct{A} and \ct{B}. This represents an iteration on a collection. 

Clicking on Message \ct{defaultNodeShapeClass} highlights the \ct{B} structure: all the red nodes indicates that exactly the same messages have been sent to the very same objects. Whereas the visualization does not indicate whether a side effect is occurring, inspecting the source code of the method \ct{defaultNodeShapeClass} clearly indicates that a memoization would reduce the amount of created objects. We augmented the definition of the method with the \textbf{bolded} code:

\begin{lstlisting}[]
MOShape class>>defaultNodeShapeClass
	"Return the default node shape class"
	| classes |
	<b>DefaultNodeShapeClass 
		ifNotNil: [ ^ DefaultNodeShapeClass ].</b>
	classes := (self allSubclasses select: #isDefaultNodeShape).
	classes ifEmpty: [ self error: 'No default shape class' ].
	^ <b>DefaultNodeShapeClass := </b>classes anyOne.
\end{lstlisting}

A new trace of the same execution is now free of the \ct{B} pattern.

%In this section we visualize the following instruction using Tree Layout (\figref{MessageCentricSample}):
%\begin{lstlisting}[language=Smalltalk]
%MessageCentricBlueprint profileView: [
%	|view|
%	view := MOViewRenderer new.
%	view nodes: AbstractBlueprint withAllSubclasses.
%] inPackagesMatching: 'Mondrian-*'.
%\end{lstlisting}
%
%
%In this context we can analyze the red message:
%\begin{lstlisting}[language=Smalltalk]
%MOShape class>>defaultNodeShapeClass
%"Return the default node shape class"
%| classes |
%classes := (self allSubclasses select: #isDefaultNodeShape).
%classes ifEmpty: [ self error: 'No default shape class' ].
%^ classes anyOne
%\end{lstlisting}
%
%This code clearly does a search twice during the execution, and the search is independent of the context because this method doesn't receive parameters and also doesn't use an instance variable. Clearly this is a method we can improve using cache.
%\begin{lstlisting}[language=Smalltalk]
%MOShape class>>defaultNodeShapeClass
%"Return the default node shape class"
%| classes |
%DefaultNodeShapeClass ifNotNil: [ ^ DefaultNodeShapeClass ].
%classes := (self allSubclasses select: #isDefaultNodeShape).
%classes ifEmpty: [ self error: 'No default shape class' ].
%^ DefaultNodeShapeClass := classes anyOne.
%\end{lstlisting}

%=========
\subsection{Reducing unnecessary collection copy}

\largefig{}{1.0}{ObjectCentricBlueprintMondrian}{Reducing unnecessary calls}

\figref{ObjectCentricBlueprintMondrian} shows the object-centric blueprint for the execution of Mondrian. Several patterns are easily identifiable. The one indicated by \ct{A}, \ct{B} and \ct{C} are particularly interesting for our case. A group of objects, marked with \ct{O}, receive exactly one message, the ones marked with \ct{A}, \ct{B} and \ct{C}. It is curious that the objects \ct{O} receive just one message without sending any.

Two methods are involved in this visual patterns: \ct{allNodesDo:} and \ct{nodesDo:}. This information is accessible via tool tip. Right clicking on a message gives access to the source code:

\begin{lstlisting}[]
MOGraphElement>>allNodesDo: aBlock
	"Evaluate aBlock all its children."
	self <b>copy</b> nodesDo: [ :each |
		aBlock value: each.
		each allNodesDo: aBlock ]
\end{lstlisting} 

The \ct{copy} message is culprit of the \ct{A}, \ct{B}, \ct{C} pattern. Removing this call suppress this unnecessary calls. When totaling with the memorization (\secref{memoization}), the amount of created nodes is down to 25, which is optimal for our profiled scenario.

%\ab{@@HERE}

%In this section we visualize the following instructions using Sequence Layout (\figref{}):
%\begin{lstlisting}[language=Smalltalk]
%|view|
%view := MOViewRenderer new.
%view nodes: AbstractBlueprint withAllSubclasses.
%ObjectCentricBlueprint profileView: [
%	view edgesFrom:#superclass.
%]  inPackagesMatching: 'Mondrian-*'.
%\end{lstlisting}
%
%In this section we will examine \figref{ObjectCentricDemo}. The first execution anomaly that we can found is in the section (A), where there are some objects that receive only one message in the execution. The following code correspond to these messages.
%
%\begin{lstlisting}[language=Smalltalk]
%MOGraphElement>>allNodesDo: aBlock
%	"Evaluate aBlock all its children."
%	self copy nodesDo: [ :each |
%		aBlock value: each.
%		each allNodesDo: aBlock ]
%\end{lstlisting} 
%
%This is a wierd code, because "self copy" do a shadow copy of the receiver node, and call to nodesDo: selector.
%
%\begin{lstlisting}[language=Smalltalk]
%MONode>>nodesDo: aBlock
%	"Iterates over all the subnodes of the receiver."	
%	nodes ifNil: [ ^ self ].
%	nodes do: aBlock
%\end{lstlisting} 
%
%And this do something with the original subnodes, this is possible to see in the visualization, but the copy nodes do nothing after that because nobody save it's reference. This is clearly an issue  and it is consuming memory needlessly.
%
%For the first execution anomaly, we refactor the ``allNodesDo:'' method: 
%\begin{lstlisting}[language=Smalltalk]
%MOGraphElement>>allNodesDo: aBlock
%	"Evaluate aBlock all its children."
%	self nodesDo: [ :each |
%		aBlock value: each.
%		each allNodesDo: aBlock ]
%\end{lstlisting} 
%
%\begin{center}
%   \begin{tabular}{|l||ccr|} \hline
%	Class & Instances & Messages \\
%	MOMorphPainterVisitor & 1 & 51	\\
%	MORectangleShape & 2 & 1602	\\
%	MOStraightLineShape & 1 & 296	\\
%	MOTreeLayout & 1 & 536	\\
%	ConcreteShapeVisitor & 49 & 98 \\
%	MONode & 25 & 5693\\
%	MOElementShapeProperties & 10 & 91\\
%	MOViewRenderer & 1 & 292\\
%	MOEdge & 24 & 3442\\
%	MORoot & 1 & 548\\
%	MOBrowser & 1 & 11\\
%	MOCanvas & 1 & 9\\
%	MOAnnouncer & 3 & 24\\
%	Total & 120 & 12696 \\
%   \end{tabular}
%\end{center}

%: % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %

%\section{Discussion}\seclabel{discussion}
%
%Group the messages only by class and packages reduce the height of a visualization. However the big number of messages remains a problem.

%: % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %

%\section{Related work}\seclabel{relatedwork}
%
%Research into trace visualization has resulted in various techniques and tools.
%
%\paragraph{Execution pattern}~\cite{Pauw98a}
%
%Execution trace visualization
%~\cite{Maoz11a}

%: % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\section{Conclusion and Future Work}\seclabel{conclusion}

The execution blueprints are effective to identify execution anomalies. One lesson we have learnt while developing the Chaski framework, is the difficulty to find visual representations that are both intuitive and scalable. Making our blueprints friendly against very large amount of data is a topic we still need to properly address.

%Also we want improve the cognitive capability on the visualization, defining and coloring execution patterns in ours blueprints.

Tracking down the cause and source of side effects is often a crucial piece of information. We plan to address this with dedicated blueprints.

Currently, the large majority of code profilers and debuggers use the inadequate abstractions in their analysis. We believe this is a critical situation that we hope the tool and ideas presented in this paper will contribute to address.

%The main objective of Chaski is help to creates blueprints that (1) is able to cope with these huge amounts of data, and (2) does not confuse the viewer.
%\paragraph{ Acknowledgment}
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %

\bibliographystyle{plain}
\tiny
\bibliography{scg}

\end{document}

