%%%%%%%%%%%%%
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
%\documentclass[runningheads]{llncs}
%\documentclass[10pt,letterpaper,twocolumn]{article}
\documentclass{sig-alternate}


% packages
\usepackage{xspace}
\usepackage{ifthen}
\usepackage{amsbsy}
\usepackage{amssymb}
\usepackage{balance}
\usepackage{booktabs}
\usepackage{graphicx}
\usepackage{multirow}
\usepackage{needspace}
\usepackage{microtype}
\usepackage{bold-extra}
\usepackage{subfigure}
\usepackage{wrapfig}


% constants
\newcommand{\Title}{Execution Blueprint: An Effective Visual Support to Monitor Software Execution}
\newcommand{\TitleShort}{\Title}
\newcommand{\Authors}{Juan Pablo Sandoval Alcocer, Alexandre Bergel}
\newcommand{\AuthorsShort}{J.P. Sandoval Alcocer, A. Bergel}

% references
\usepackage[colorlinks]{hyperref}
\usepackage[all]{hypcap}
\setcounter{tocdepth}{2}
\hypersetup{
	colorlinks=true,
	urlcolor=black,
	linkcolor=black,
	citecolor=black,
	plainpages=false,
	bookmarksopen=true,
	pdfauthor={\Authors},
	pdftitle={\Title}}

\def\chapterautorefname{Chapter}
\def\appendixautorefname{Appendix}
\def\sectionautorefname{Section}
\def\subsectionautorefname{Section}
\def\figureautorefname{Figure}
\def\tableautorefname{Table}
\def\listingautorefname{Listing}

% source code
\usepackage{xcolor}
\usepackage{textcomp}
\usepackage{listings}
\definecolor{source}{gray}{0.9}
\lstset{
	language={},
	% characters
	tabsize=3,
	upquote=true,
	escapechar={!},
	keepspaces=true,
	breaklines=true,
	alsoletter={\#:},
	breakautoindent=true,
	columns=fullflexible,
	showstringspaces=false,
	basicstyle=\footnotesize\sffamily,
	% background
	frame=single,
    framerule=0pt,
	backgroundcolor=\color{source},
	% numbering
	numbersep=5pt,
	numberstyle=\tiny,
	numberfirstline=true,
	% captioning
	captionpos=b,
	% formatting (html)
	moredelim=[is][\textbf]{<b>}{</b>},
	moredelim=[is][\textit]{<i>}{</i>},
	moredelim=[is][\color{red}\uwave]{<u>}{</u>},
	moredelim=[is][\color{red}\sout]{<del>}{</del>},
	moredelim=[is][\color{blue}\underline]{<ins>}{</ins>}}
\newcommand{\ct}{\lstinline[backgroundcolor=\color{white},basicstyle=\footnotesize\ttfamily]}
\newcommand{\lct}[1]{{\small\tt #1}}

% tikz
% \usepackage{tikz}
% \usetikzlibrary{matrix}
% \usetikzlibrary{arrows}
% \usetikzlibrary{external}
% \usetikzlibrary{positioning}
% \usetikzlibrary{shapes.multipart}
% 
% \tikzset{
% 	every picture/.style={semithick},
% 	every text node part/.style={align=center}}

% proof-reading
\usepackage{xcolor}
\usepackage[normalem]{ulem}
\newcommand{\ra}{$\rightarrow$}
\newcommand{\ugh}[1]{\textcolor{red}{\uwave{#1}}} % please rephrase
\newcommand{\ins}[1]{\textcolor{blue}{\uline{#1}}} % please insert
\newcommand{\del}[1]{\textcolor{red}{\sout{#1}}} % please delete
\newcommand{\chg}[2]{\textcolor{red}{\sout{#1}}{\ra}\textcolor{blue}{\uline{#2}}} % please change
\newcommand{\chk}[1]{\textcolor{ForestGreen}{#1}} % changed, please check

% comments \nb{label}{color}{text}
\newboolean{showcomments}
\setboolean{showcomments}{true}
\ifthenelse{\boolean{showcomments}}
	{\newcommand{\nb}[3]{
		{\colorbox{#2}{\bfseries\sffamily\scriptsize\textcolor{white}{#1}}}
		{\textcolor{#2}{\sf\small$\blacktriangleright$\textit{#3}$\blacktriangleleft$}}}
	 \newcommand{\version}{\emph{\scriptsize$-$Id$-$}}}
	{\newcommand{\nb}[2]{}
	 \newcommand{\version}{}}
\newcommand{\rev}[2]{\nb{Reviewer #1}{red}{#2}}
\newcommand{\ab}[1]{\nb{Alexandre}{blue}{#1}}
\newcommand{\vp}[1]{\nb{Vanessa}{orange}{#1}}
\newcommand{\jp}[1]{\nb{Juan Pablo}{green}{#1}}

% graphics: \fig{position}{percentage-width}{filename}{caption}
\DeclareGraphicsExtensions{.png,.jpg,.pdf,.eps,.gif}
\graphicspath{{figures/}}
\newcommand{\fig}[4]{
	\begin{figure}[#1]
		\centering
		\includegraphics[width=#2\textwidth]{#3}
		\caption{\label{fig:#3}#4}
	\end{figure}}

\newcommand{\largefig}[4]{
	\begin{figure*}[#1]
		\centering
		\includegraphics[width=#2\textwidth]{#3}
		\caption{\label{fig:#3}#4}
	\end{figure*}}
	
\newcommand{\wrapfig}[5]{	
\begin{wrapfigure}{#1}{#2\textwidth}
  \begin{center}
    \includegraphics[width=#3\textwidth]{#4}
  \end{center}
  \caption{\label{fig:#4}#5}
\end{wrapfigure}}

% abbreviations
\newcommand{\ie}{\emph{i.e.,}\xspace}
\newcommand{\eg}{\emph{e.g.,}\xspace}
\newcommand{\etc}{\emph{etc.}\xspace}
\newcommand{\etal}{\emph{et al.}\xspace}

% lists
\newenvironment{bullets}[0]
	{\begin{itemize}}
	{\end{itemize}}

\newcommand{\seclabel}[1]{\label{sec:#1}}
\newcommand{\figlabel}[1]{\label{fig:#1}}
\newcommand{\figref}[1]{Figure~\ref{fig:#1}}
\newcommand{\secref}[1]{Section~\ref{sec:#1}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% adding smalltalk listing %%%%%%%%%%%%%%%%%%%5
\lstdefinelanguage{Smalltalk}{
  morekeywords={true,false,self,super,nil},
  sensitive=true,
  morecomment=[s]{"}{"},
  morestring=[d]',
  style=SmalltalkStyle
}
\lstdefinestyle{SmalltalkStyle}{
  literate={:=}{{$\gets$}}1{^}{{$\uparrow$}}1
} 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% adding smalltalk listing %%%%%%%%%%%%%%%%%%%5

%Specialized macros
\newcommand{\hapao}{Hapao\xspace}
\newcommand{\Hapao}{Hapao\xspace}
\pagenumbering{arabic}

\begin{document}

\title{\Title}
%\titlerunning{\TitleShort}

\author{\Authors\\[3mm]
Department of Computer Science (DCC)\\ University of Chile, Santiago, Chile\\[1 ex]
} 
%\authorrunning{\AuthorsShort}

\maketitle

\emph{This paper makes use of colored figures. Though colors are not mandatory for full understanding, we recommend  the use of a colored printout.}

\begin{abstract}
%	What's the problem.
%	Why is the problem a problem?
%	What's the surprising idea?
%	What's the consequence?

Understanding the behavior of software is one essential task of the software life cycle, especially when maintenance activities have to be performed. One has to analyze the code, the documentation or any other device before making any changes therefore it becomes a difficult task and time consuming.

Our goal is to show a visualization that represents the interaction of objects involved in the execution which can help developers gain a better understanding of the software execution. The large number of objects involved in execution represents a major challenge.

Chaski is a tool to address this problem of understanding by visualizing the execution of an object oriented program. Execution blueprint shows the interaction between objects through messages exchanged between them, in the order they occur. \ab{Say more about the visualization}. This visualization helps to: understand the current behavior of the software, find candidates for refactoring and optimization, show dependencies and relations, among others.


\end{abstract}

%: % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %

\section{Introduction}\seclabel{introduction}

The use of highly reflective dynamic languages can make seemingly simple questions(how 2 or more packages interact? What kinds are dependent to a certain class? When exactly this method is invoked?)difficult to answer if we just analyze the source code, documentation or any other appliance design.

To answer these questions among others and to improve the process of understanding, it is necessary to make a dynamic analysis, or analysis of data retrieved from the execution of a program.

In this context, we propose a visualization of the execution of an object oriented program, showing the interaction between objects through messages exchanged between them, in the order they occur. While understanding the overall behavior of the system is ideal, this visualization was intended to be used by objectives, in other words, to analyze portions of the application that really interest us to achieve an objective.

The purpose of this visualization is to help: understand the current behavior of the software, find candidates for refactoring and optimization, show dependencies and relations, among others.

%: % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\section{Execution Blueprint}\seclabel{executionBlueprint}

\subsection{In a nutshell}

\fig{}{0.5}{Demo}{Execution Blueprint in a nutshell}
Execution Blueprint is a visualization that represents the timeline of an application execution. It is obtained after to execute the application according to an execution scenario. An execution scenario being an instance of one or more use cases. (\figref{Demo})

Execution Blueprint distinguishes three types of components: classifiers, messages and edges. The classifiers are displayed as blue, red and yellow boxes that represent a package, class and object respectively(A). The gray boxes represent messages(B). And the edges link pairs of messages, where a message is related to the message from which it was invoked.

The classifiers are displayed as a composition. By example in the \figref{Demo} the packages are composed for its classes  and each class is composed from the objects that were instantiated from it (E).

The messages are vertically aligned with the component receiving the message(D) and placed horizontally in the order in which these messages are received (timeline).


%=========
\subsection{Layout}

%\largefig{}{1.0}{TestSuite}{Visualizing a Test Suite execution (RBSmallDictionaryTest buildSuite run)}

The essence of ``layout'' are the messages and the chronological order in which messages are received. And it classifies the messages into groups, as seen in the example in \figref{Demo}, where the messages are classified first by class package and finally by object.

While the messages are horizontally sorted in a chronological order, the other components (package, class, object) are sorted vertically by number of messages that has been sent, in this sense the component that sends more messages are located above (\figref{Demo} - C).

Also we can set different colors to the messages based on a criteria, depending on what we want to use the visualization for.

%The classification of messages may vary depending on what one want to analyze. For example the \figref{TestSuite} only classifies the messages by object, because we want analyze the relation between objects that participate of an test suite execution. Note that one of the important features of a suite of tests is that they should be independent of each other: the failure of one test should not cause an avalanche of failures of other tests that depend upon it, nor should the order in which the tests are run matter. Performing setUp before each test and tearDown afterwards helps to reinforce this independence.

%=========
\subsection{Patterns}

Execution Blueprint allows identifying some execution pattern to help the developer have a better understanding of the current behavior of software and to reduce the analysis time of the visualization in order to enhance the software.

The patterns in Execution Blueprint are classifiers of  recurrent behavior in the visualization. In order to identify patterns in the visualization we use colors in the message based on a criteria. Below we describe the patterns that we found in the visualization.

{\bf Class Common Interaction} represents the common interaction of the different instances from some classes. ... We can identify this pattern when two or more sections of the visualization have the same sequence of messages but the messages for each section were sent and received by different instances from some classes. Detecting the pattern "common interaction" (\figref{ClassIdentity} - A) allows us to analyze and ask ourselves if its necessary to have those instances of that class; if the answer is no, one could re-factor controlling the number of instances of those classes, in this case we could use flyweight factory or singleton design patterns.

{\bf Object Common Interaction} represents a specification of the pattern ``Class Common Interaction'', where two or more sections of the visualization have a common sequence of messages and there is a perfect match between objects and messages (\figref{YYY} - A). Which implies that the messages of each sections are transmitted and received by the same objects. Again. we can ask ourselves: Do I need to do the same two or more times?.  If the answer is no, you could re-factor this using cache in order to not to do the same operations two or more times.

{\bf Lineal interaction}, represents an interaction of only one object with yourself. Where the messages are sent or received by the same object (\figref{LinealInteraction} green boxes). This pattern no necessary detect a possible problem, because objects do not interact with other objects of different classes or packages, this represent an independent behavior (atomic).


{\bf Iterative interaction}, represents an iteration over a collections of objects (\figref{IteratorPattern}). Where a message (A) appears as a origin of one o more common interactions (B). This pattern helps us to find common interaction patterns.
	
{\bf Reflexive interaction}, represents the invocations themselves as objects, sending the same message to different objects. We can see this pattern in the \figref{ReflexivePattern} (A), where the magenta messages has the same selector. This pattern us to find common interactions like the iterative pattern.


\fig{}{0.5}{ClassIdentity}{ Class Common Interaction}
\fig{}{0.5}{LinealInteraction}{Lineal Interaction}
\fig{}{0.5}{IteratorPattern}{Iterator Interaction}
\fig{}{0.5}{ReflexivePattern}{Reflexive Interaction}
%: % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\section{Case Study}\seclabel{case study}

\subsection{Mondrian}

\largefig{}{1.0}{Before1}{Execution anomalies}
We will use Mondrian to demonstrate how ``Execution BluePrint'' visualization is useful to understand the current behavior of the software and find candidates for refactoring and optimization. To which we will address the visualization for the following code execution \figref{Mondrian1}:
\begin{lstlisting}[language=Smalltalk]
	...
	view  :=  MOViewRenderer title: 'Chaski'.
	view nodes: MOGraphElement withAllSubclasses.
	Chaski profile:[ 
		view edgesFrom: #superclass.
		] inPackagesMatching:'Mondrian-*'.
	Chaski visualize.
	...
\end{lstlisting}


\subsection{Execution anomalies}

In this section we will examine \figref{Before1}. The first execution anomaly that we can found is in the section (A), where there are some objects that receive only one message in the execution. The following code correspond to these messages.

\begin{lstlisting}[language=Smalltalk]
MOGraphElement>>allNodesDo: aBlock
	"Evaluate aBlock all its children."
	self copy nodesDo: [ :each |
		aBlock value: each.
		each allNodesDo: aBlock ]
\end{lstlisting} 

This is a wierd code, because "self copy" do a shadow copy of the receiver node, and call to nodesDo: selector.

\begin{lstlisting}[language=Smalltalk]
MONode>>nodesDo: aBlock
	"Iterates over all the subnodes of the receiver."	
	nodes ifNil: [ ^ self ].
	nodes do: aBlock
\end{lstlisting} 

And this do something with the original subnodes, this is possible see in the visualization. but the copy nodes do nothing after that because no body save it's reference. This is clearly an issue  and it is consuming memory needlessly.


\subsection{Improvement}

\largefig{}{1.0}{After1}{Improvement}
For the first execution anomaly, we refactor the ``allNodesDo:'' method: 
\begin{lstlisting}[language=Smalltalk]
MOGraphElement>>allNodesDo: aBlock
	"Evaluate aBlock all its children."
	self nodesDo: [ :each |
		aBlock value: each.
		each allNodesDo: aBlock ]
\end{lstlisting} 


%: % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\section{Managing the scalability}\seclabel{scalability}

\jp { Delete??}
%The large number of objects and messages involved in an object-oriented program execution makes the visualization extremely large and difficult to analyse.

%In order to reduce the visualization size is recommended to group the messages simply by class and package. In addition we can use colors in messages can help to a better analisis.

%Being able to find repetitive behavior,it is possible to have a reduced version of litle set of message sequence that represent all execution. This would allow greatly reduce the visualializacion, in the future.

%: % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\section{Discussion}\seclabel{discussion}

The large-scale sequence of messages makes the screen resolution not enough to show a lot of information,causing the emergence of scrolls that make the graphics difficult to understand. Group the messages only by class and packages reduce the height of a visualization. However the big number of messages remains a problem.


%: % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\section{Implementation}\seclabel{implementation}

\subsection{Chaski}

Chaski is a tool that implement the layout of Execution Blueprint in Pharo. And allows analyze portions of the application that really interest us to achieve an objective. To do the case study, we use the following script with Chaski.

\begin{lstlisting}[language=Smalltalk]
	view  :=  MOViewRenderer title: 'Chaski'.
	view nodes: MONode withAllSubclasses.
	Chaski profile:[ 
		view edgesFrom: #superclass.
		] inPackagesMatching:'Mondrian-*'.
	Chaski exportAsHTML.
\end{lstlisting}

Chaski allow apply filter in the visualizations components. In the case of last code we apply a filter in order to display only packages that start with ``Mondrian-''. And we only analyze how Mondrian establish the edges with the method ``edgesFrom''.

\fig{}{0.3}{Chaski}{Chaski}

As shown in the \figref{Chaski}, Chaski was created as an especification of Spy coupled with Mondrian to render profiled information.

%\fig{}{0.5}{ObjectModel}{Structure of Chaski}

%The core classes for Chaski are depicted in \figref{ObjectModel}. Note that there are two additional classes to the basic structure of Spy, they are ChaskiObject and ChaskiMessage. This is because "Execution Blueprint" makes an analysis beyond class or method.

%Chaski classify messages by packages, class and object by default. And provide options to group messages with different criteria such as \figref{Mondrian1} that only group messages by packages and class. The code below remove object classifier from Chaski default configuration.

%\begin{lstlisting}[language=Smalltalk]
%...
%Chaski config displayObjectsThat:[ :aChaskiObject | false].
%Chaski visualize.
%\end{lstlisting}

%Also is posible classify messages only by object, with the code below. Where we need remove package and class classifiers form Chaski default configuration (\figref{ChaskiPreview8}).
%\begin{lstlisting}[language=Smalltalk]
%...
%Chaski config displayPackagesThat:[:aChaskiPackage | false].
%Chaski config displayClassesThat:[ :aChaskiClass | false].
%Chaski visualize.
%\end{lstlisting}

%: % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\section{Related work}\seclabel{relatedwork}

Research into trace visualization has resulted in various techniques and tools.


%: % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %

\section{Conclusion}\seclabel{conclusion}

%\paragraph{Acknowledgment}
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %

\bibliographystyle{plain}
\bibliography{scg}

\end{document}

